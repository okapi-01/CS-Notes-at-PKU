# 信息安全引论

2025秋

---



# Lecture 1. 绪论

课程体系：密码学基础、认证理论与技术、网络安全与应用安全、软件与系统安全、专题讲座

- 信息安全的含义 CIA: Confidentiality, Integrity, Availability

  - Confidentiality 数据机密性：外人不可阅读
  - Privacy 隐私性：个人控制与其相关的信息的收集、存储、披露
  - Integrity 数据完整性
  - Integrity 系统完整性：系统未被非授权操纵，按既定的功能运行
  - Availability 可用性：保证信息和信息系统随时为授权者提供服务，而不要出现非授权者滥用却对授权者拒绝服务的情况
  - 其他：真实性Authenticity`确认实体是它所声明的`、可审计性Accountability、可靠性Reliability`行为和结果的一致性`、不可否认性Non-repudiation`防止源点或终点的抵赖`

- $P^2DR$安全模型：policy`意味着网络安全要达到的目标`, protection, detection, response

  要求：Pt > Dt + Rt `保护机制有效发挥作用的时间>检测到+反应时间`

---



# Lecture 2. 古典密码

密码学 = 密码编码学`(编码)` + 密码分析学`(破译)`

## 一、密码学

- 密码算法的安全性
    - 【无条件安全】无论破译者有多少密文，他也无法解出对应的明文，即使他解出了，他也无法验证结果的正确性。
    - 【计算上安全】破译的代价超出信息本身的价值 或 破译的时间超出了信息的有效期。

### 密码编码

- 密码体制：五元组（P, C K, E, D）
  - P: 明文空间（所有可能的明文的有限集）
  - C: 密文空间
  - K: 密钥空间
  - E: 加密算法
  - D: 解密算法
- 密码算法分类
  1. 按保密内容分为
     - 基于算法的算法：需要保证算法不公开，aka受限制的算法)
     - 基于密钥的算法：这个更好，可以让大家都来测试该算法是否安全
  2. 按密钥特点分为
     - 对称密钥算法：加密&解密使用一致的密钥，aka 传统密码算法、秘密密钥、单密钥
     - 非对称密码算法：aka公开密钥算法，用一个密钥进行加密，而用另一个进行解密。其中的加密密钥可以公开，又称公开密钥（public key)，简称公钥。解密密钥必须保密，又称私人密钥（private key），简称私钥。
  3. 按明文的处理方法分为
     - 分组密码：将明文分成固定长度的组，用同一密钥和算法对每一块加密，输出也是固定长度的密文。`公钥密码一般为分组密码` `加密解密速度慢`
     - 流密码：又称序列密码。序列密码每次加密一位或一字节的明文，也可以称为流密码。
- Kerckhoff原则 【古典密码和现代密码的分界线】：加密算法应建立在算法的公开不影响明文和密钥的安全的基础上。

### 密码分析

- 攻击类型：
  1. 唯密文攻击：面前只有一串密文串。
  2. 已知明文攻击: 知道明文串x和相应的密文y。
  3. 选择明文攻击：可获得对加密机的暂时访问，因此能选择明文串x并构造出相应的密文串y。
  4. 选择密文攻击：可暂时接近密码机，可选择密文串y，并构造出相应的明文x。



## 二、密码学的起源和发展

1949年之前 密码学是一门艺术（思想：代替、置换，仍是当今基本思想）
1949～1975年 密码学成为科学
1976年以后 密码学的新方向——公钥密码学



## 三、古典密码

### 代替密码

#### 简单代替密码

- aka单字母密码，只替换一位字母

  [前置知识：逆元](#逆元)

  (1) 移位密码：x+a `密钥个数：25`

  (2) 乘数密码：ax `密钥个数：11（需要a与26互素）`

  (3) 仿射密码：ax+b `密钥个数：311`

  

  (4) 密钥短语密码：eg. 取university为密钥，首先找出其中发生重复的字母，去掉重复字母i，成为universty。其次，字母一共10个，从第11个字母开始，写成universty。然后把其余17个字母按自然顺序接在后面。<img src="./信息安全引论.assets/image-20250918222155163.png" alt="image-20250918222155163" style="zoom:33%;" />

  

  (5) 任意的单表代替密码：一个任意的一一映射 `密钥空间很大，不能暴力枚举`

  - Sol. 利用语言的统计特性（字母的频率特征、[连接特征](q后接u，两个e间接r)、[重复特征](th, tion, tious)）`偏用现象：每个字母使用频率不一致`

    - Anti_Sol1. 多名代替密码：一对多转换，A可能对应于5、13、25，B可能对应于7、9、31、42。
    
    - Anti_Sol2. 多表代替密码：使用多张表来映射
    
      


#### 多表代替密码

- 多表代替：

  i. 维吉尼亚密码 <img src="./信息安全引论.assets/image-20250918164725370.png" alt="image-20250918164725370" style="zoom:33%;" />

  - 维吉尼亚密码的破译：只需要确定密钥长度，即可分表进行统计学分析。

    - Kasiski测试法：寻找“合拍”现象，求间隔的最大公因数。`可能会有偶然重合，从统计意义角度看即可`<img src="./信息安全引论.assets/image-20250918223814668.png" alt="image-20250918223814668" style="zoom:33%;" />

    - 重合指数法：对于一篇正常的英语文章&正常的字母出现频率，可以求得随机抽两个字母，抽到两个相同字母的概率为 $p_1^2+p_2^2+...+p_{26}^2=0.0687$，则拆分为d组计算平均重合指数，若接近0.0687则周期为d。

  ii. 滚动密钥密码：密钥与明文一样长。*缺陷：不易保管密钥*

  <img src="./信息安全引论.assets/image-20250925151904312.png" alt="image-20250925151904312" style="zoom:33%;" />

  iii. Vernam密码：异或一段等长二进制串（思想：密钥与明文一样长且没有统计关系）。加密解密均异或该二进制串即可。

  iv. 转轮密码机：分为快、慢、中转子，每个转子实现一个映射，每个转子都可以转26个位置，则有26 * 26 * 26 = 175756的密码空间（可以更多转子）。*在现代密码发明之前是最常用的密码实现*

  

#### 多字母代替密码

- 明文中的字符映射到密文空间的字符还依赖于它在上下文中的位置。

  i. Playfair密码：将明文中的双字母组合作为一个单元转换成密文的双字母组合。

  <img src="./信息安全引论.assets/image-20250925153725859.png" alt="image-20250925153725859" style="zoom:33%;" />

  ii. Hill密码：假设 K 是一个 $m \times m$ 矩阵，在 $\mathbb{Z}_{26} $ 上可逆，即存在 $K^{-1}$ 使得：$KK^{-1} = I$, 对每一个 $k \in K$，定义$e_k(x) = xK \ (\text{mod}\ 26)$ 和 $d_k(y) = yK^{-1} \ (\text{mod}\ 26)$

  <img src="./信息安全引论.assets/image-20250927192546095.png" alt="image-20250927192546095" style="zoom:40%;" />
  
  *很难被唯密文攻击攻破，但易被已知明文攻击攻破（直接解方程即可得到矩阵）*



### 置换密码

1. 栅栏密码

   <img src="./信息安全引论.assets/image-20250925155147031.png" alt="image-20250925155147031" style="zoom:33%;" />

2. 置换密码：按行写入，按列读出，密钥包含行宽、列高、读出顺序。`可多轮置换减少结构性排列`

   <img src="./信息安全引论.assets/image-20250927192906123.png" alt="image-20250927192906123" style="zoom:33%;" />

---



前置知识-逆元<a name="逆元"></a>

- 如果 $(a \times b)\mod q = (a \times c) \mod q$，当 a 与 q 互素时，$b \equiv c \mod q$。

- 如果 q 是一个素数，对每一个非 0 元 $w \in \mathbb{Z}_q$，都存在 z，使得 $w \times z \equiv 1 \mod q$，z 称作 w 的乘法逆元 $w^{-1}$。

- 乘法逆元计算

  - 裴蜀定理：若a、b是整数且他们的最大公约数gcd(a,b) =d，那么对于任意的整数x，y，ax+by都一定是d的倍数，特别地，一定存在整数x与y，使得ax + by = d = gcd(a,b)成立。*即a、b的公因数为a、b线性组合所能得到的最小正整数.*

  - 扩展Euclid算法：

    目的：求出ax + by = gcd(a,b)中的x和y

    本质：还原辗转相除法所得到余数的过程

    ​	eg. 100 35 --> 35 30 --> 30 5

    ​	则5 = 35 - 30 = 35 * 1 - (100 * 1 - 35 * 2) = 100 * (-1) + 35 * 3

    ​	则x=-1, y=3

    具体公式：$s_{i+1}=s_{i-1}-s_iq_i，t_{i+1}=t_{i-1}-t_iq_i$ ($q为商，s_0=0, s_1=1,t_0=1,t_1=0，从2开始$)


---



# Lecture 3. 现代对称密码

## 一、分组密码的设计原理与方法

<img src="./信息安全引论.assets/image-20250928163451707.png" alt="image-20250928163451707" style="zoom:33%;" />

现实中DES的有效密钥长度仅为56 位，AES 的密钥长度为128/196/256。希望找到的算法，能在密钥的控制之下，从一个足够大而且足够好的代替子集中，简单而迅速地选取出一个代替。要求：分组长度够长；密钥空间大；密钥长度不能过长；由密钥确定代替的算法足够复杂。

##### 两个基本设计方法

理想密码系统中，密文的所有统计特性都与所使用的密钥独立。

- Diffusion 扩散：密文没有统计特征；明文一位影响密文多位；增加明文密文关系复杂性。*置换*
- Confusion 混淆：强调密钥的作用；增加密钥密文关系复杂性。*代替*



## 二、乘积密码

考虑连续使用两个或两个以上的基本密码的方式来增强密码强度。

- 要求：第一个方法的密文空间与第二个方法的明文空间一致；两个方法不满足交换性；两个方法相互独立
- 群：某些密码体制M具有以上性质，取自M的两个加密步的合成仍属于M，也就是说这一密码体制形成群。



## 三、数据加密标准DES

征集标准加密算法时的要求：
- 算法必须提供高度的安全性
- 算法必须有详细的说明 并易于理解
- 算法的安全性取决于密钥 不依赖于算法
- 算法适用于所有用户
- 算法适用于不同应用场合
- 算法必须高效、经济
- 算法必须能被证实有效
- 算法必须是可出口的

### Feistel 密码结构

<img src="./信息安全引论.assets/image-20250925165725956.png" alt="image-20250925165725956" style="zoom:40%;" />

- 分组大小。越大安全性越高，但速度下降，64 比特较合理
- 密钥位数。越大安全性越高，但速度下降，64 比特广泛使用，但现在已经不够用→ 128 比特
- 循环次数，典型16次
- 子钥产生算法。算法越复杂，就增加密码分析的难度
- round轮函数。函数越复杂，就增加密码分析的难度
- 快速软件实现，包括加密和解密算法
- 易于分析。便于掌握算法的保密强度以及扩展办法。
- 软件实现的要求：使用子块和简单的运算。密码运算在子块上进行，要求子块的长度能自然地适应软件编程，如8 、16 、32 比特等。应尽量避免按比特置换，在子块上所进行的密码运算尽量采用易于软件实现的运算。最好是用标准处理器所具有的一些基本指令，如加法、乘法、移位等。
- 硬件实现的要求：加密和解密的相似性，即加密和解密过程的不同应仅仅在密钥使用方式上，以便采用同样的器件来实现加密和解密，以节省费用和体积。尽量采用标准的组件结构，以便能适应于在超大规模集成电路中实现。

### DES

**分组长度64bit；密钥长度64bit（有效56bit）；循环次数16次。**

整体流程：<img src="./信息安全引论.assets/image-20250928172512333.png" alt="image-20250928172512333" style="zoom:40%;" />  轮操作：<img src="./信息安全引论.assets/image-20250928172403373.png" alt="image-20250928172403373" style="zoom:40%;" />

#### 轮操作

1. IP：初始置换，64bits->64bits

2. 切成两半 64bits->32bits，并对右半32bits开始做轮操作

3. 扩展置换E：32bits->48bits

   <img src="./信息安全引论.assets/image-20250928173112648.png" alt="image-20250928173112648" style="zoom:43%;" />

4. 和密钥产生器产生的48bits密钥异或，48bits->48bits

5. S盒选择压缩：48bits->32bits

   - 共8个S盒。对每个盒，输入6进制输出4进制，第1和6位确定行，2345位确定列，通过表确定输出。

6. P盒置换：置换. 32bits->32bits

7. 和左半异或。32bits->32bits

8. 反复迭代16轮

9. 64bits通过IP$^{-1}$ 置换，得到密文。


#### 密钥产生器

有64位初始密钥，需要生成16个不同48位密钥。

<img src="./信息安全引论.assets/image-20250928173705480.png" alt="image-20250928173705480" style="zoom:50%;" />

1. 去掉校验位 64bits->56bits

2. 置换选择，通过置换表

3. 分成左右两半并各自根据移位表移位

   <img src="./信息安全引论.assets/image-20250928173852072.png" alt="image-20250928173852072" style="zoom:50%;" />

4. 置换选择，通过置换表56bits->48bits

*明文或密钥的一点小的变动应该使密文发生一个大的变化，这叫**雪崩效应**。

#### 雪崩效应

- 严格雪崩准则SAC（Strict avalanche criterion)：对于任何的i j，当任何一个输入比特i变化时，一个S盒子的任何输出比特j变化的概率为1/2 。
- 比特独立准则BIC (bit independence criterion)：对于任意的i j k，当任意一个输入比特i变化时，输出j和k应当独立地变化。

雪崩准则的目标：消除明文与密文的统计依赖性，对抗统计分析攻击防止“局部篡改可预测”，模拟 “伪随机性”，确保密文无可识别模式。雪崩准则是“扩散特性”的量化实现。

P盒的设计准则：

1. 第 i 次循环时从每个 S 盒子输出的四个比特被分布开，以便其中的两个影响第i+1 次循环的中间比特，而另外的两个影响两端的比特。
2. 每个 S 盒的 4 位输出都要影响下一循环的 6 个S 盒，且没有任何两位影响同一个 S 盒。
3. 如果一个 S 盒的 4 位输出位影响另一个 S 盒的中间 1 位，那么后一个的输出位不会影响前一个S 盒的中间1 位

### 对DES的讨论

#### 弱密钥

- 定义：若密钥 K 满足$ E_K(E_K(M)) = M$（即加密两次后恢复明文），则 K 为弱密钥。

- DES共有4个弱密钥：左右两半各自全为1/全为0.（除了校验位）*DES 的加密和解密流程几乎相同，唯一区别是子密钥的使用顺序。对于全0/全1密钥，由于所有子密钥相同，因此加密=解密。*

  <img src="./信息安全引论.assets/image-20251011140922158.png" alt="image-20251011140922158" style="zoom:30%;" />

#### 半弱密钥

- 定义：若存在两个不同密钥使得 $E_{K_1}(E_{K_2}(M)) = M$（即 K1 加密后可用 K2 解密），则称K1K2为半弱密钥对。*半弱密钥对生成的子密钥序列互为逆序，导致加解密操作可相互抵消。*

- DES共有12个半弱密钥

  <img src="./信息安全引论.assets/image-20251011141236069.png" alt="image-20251011141236069" style="zoom:35%;" />

#### 互补密钥

将密钥的0换成1，1换成0，就得到该密钥的补密钥。如果用原密钥加密一组明文，则用补密钥可以将明文的补码加密成密文的补码。即$E_k (M)=C，E_k'(M' )=C'$。

那么在选择明文攻击中，选择明文X，使用机器得到E(X)=Y1和E(X')=Y2。然后穷举密钥T，对X进行加密运算，如果得到结果为Y1或Y2'，则找到了密钥：T或T'。这样即可减少一半的计算量，$2^{56}到2^{55}$。

*其实现在算力发展，已经可以一天之内穷举出一个密钥了，所以DES已经不安全了。*

#### DES的破译

- 差分密码分析法：使用2^47对明密文的选择明文攻击
- 线性密码分析法：使用2^47对明密文的已知明文攻击 *思想：找到一个线性拟合函数*

#### DES的轮数

一般来说，循环次数的选择准则是要使已知的密码分析的工作量大于简单的穷举式密钥搜索的工作量。

对于16 个循环的DES 来说，差分密码分析的运算次数为2^55.1^，而穷举式搜索要求2^55^，前者比后者效率稍低，如果DES循环15次，那么差分密码分析比穷举式搜索的工作量要小。

#### S盒设计原理未知

S盒是许多密码算法的唯一非线性部件 因此 它的密码强度决定了整个算法的安全强度，提供了密码算法所必须的混淆作用。

如何全面准确地度量S 盒的密码强度和设计有效的S 盒是分组密码设计和分析中的难题：非线性度、差分均匀性、严格雪崩准则、可逆性、没有陷门

### Double DES

已经证明DES不能成为群（即用k1做一遍加密、再用k2做一遍加密，无法等效于用k3做一遍加密）。所以：做两遍DES！

#### 弱点

**中间相遇攻击**：如果拿到了一对明文密文对(P, C)，则对所有$2^{56}$个密钥，加密P，对结果排序；对所有$2^{56}$个密钥，解密C，对结果排序；逐个比较，即可找出K1 K2 使得$E_{K1} (P) = D_{K2} (C)$

给定一个明文P，经二重DES 加密有2^64^个可能的密文。而二重DES 所用密钥的长度应是112 bits，所以选择密钥有2^112^ 个可能性。于是对给定一个明文P 加密成同样密文有2^112^ /2^64^ =2^48^ 种可能。拿这么多种可能去试第二对明密文对，因为密文空间是2^64^，所以只有2^48-64^ =2^-16^ 的概率又蒙对一个。所以说，对已知2个明文 密文对的中间相遇攻击成功的概率为1-2^-16^ 。
攻击用的代价(加密或解密所用运算次数) ≤ 4 * 2^56^，需要大量的存储器。

### Triple DES

有多种模式：

- DES-EEE3：三个不同密钥，顺序使用三次加密
- DES-EDE3：三个不同密钥，依次加密-解密-加密 *与DES 的兼容性可以通过令K3 =K2 或 K1 = K2得到。*
- DES-EEE2：K1=K3
- DES-EDE2：K1=K3

目前还没发现有效攻击方式，密码有效长度可达168位。对其密钥空间中密钥进行蛮干搜索，那么由于空间太大为$2^{112}=5 × 10^{33}$，这实际上是不可行的。若用差分攻击的方法，相对于单一DES来说复杂性以指数形式增长，要超过1e52 。

许多基于Internet 的应用里用到：PGP 和S/MIME。



## 四、其他现代对称分组密码

### AES（Rijndael）

Advanced Encryption Standard，Rijndael算法胜出。

要求：比三重DES快、至少与三重DES一样安全、**数据分组长度为128比特、密钥长度为128/192/256比特（分别循环10、12、14轮）**。

#### 数学基础

**一元多项式环。**

#### 加密流程

<img src="./信息安全引论.assets/image-20251011163942832.png" alt="image-20251011163942832" style="zoom:43%;" />

##### 初始变换

和子密钥K0进行异或（以字节为单位排成矩阵）。<img src="./信息安全引论.assets/image-20251011164213965.png" alt="image-20251011164213965" style="zoom:43%;" />

##### 轮操作

1. 字节代替

   <img src="./信息安全引论.assets/image-20251009165418383.png" alt="image-20251009165418383" style="zoom:40%;" />

   是由有限域算出来的，具备抗差分分析的能力。

2. 行移位变换

   <img src="./信息安全引论.assets/image-20251011164347837.png" alt="image-20251011164347837" style="zoom:50%;" />

3. 列混淆变化（最后一轮没有这个步骤）

   <img src="./信息安全引论.assets/image-20251011215212902.png" alt="image-20251011215212902" style="zoom:50%;" />

   可以理解为每一列左乘一个矩阵。但是“乘法”的实际进行为↓

   <img src="./信息安全引论.assets/image-20251011215306713.png" alt="image-20251011215306713" style="zoom:50%;" />

4. 轮密钥加：密钥经过密钥扩展得到十个子密钥，每一轮最后和该轮子密钥异或。

##### 密钥扩展

1. 对于不整除4的轮密钥：W[i] = W[i-4] ^ W[i-1]

2. 对于整除4的轮密钥：W[i] = W[i-4] ^ G(W[i-1])

   G函数：i. 一字节左移：[b0,b1,b2,b3] -> [b1,b2,b3,b0]

   ​	ii. 用S盒进行字节替换

   ​	iii. 前两步的结果异或轮常数Rcon[j]

   ​	<img src="./信息安全引论.assets/image-20251011215748798.png" alt="image-20251011215748798" style="zoom:43%;" />

#### 安全性

Rijndael 能够抵抗目前已知的攻击算法（线性攻击、差分攻击），没有发现弱密钥或补密钥。

<img src="./信息安全引论.assets/image-20251016151734348.png" alt="image-20251016151734348" style="zoom:33%;" />

### SM4

- 商密SM4.0（原名SMS4.0）是我国政府采用的一种分组密码标准，由国家密码管理局于2012年发布。
- 国密即国家密码管理局认定的国产密码算法。https://www.oscca.gov.cn/
- SM1为对称加密。其加密强度与AES相当。该算法不公开。
- SM4**分组长度与密钥长度均为128bit，迭代轮数 32 轮**，改进的Feistel结构
- 政策依据：《密码法》要求关键信息基础设施必须使用国密算法；等保 2.0 三级以上系统需采用 SM4 加密传输。
- 国产化改造：金融领域需替换 AES 为 SM4。



## 五、分组密码的操作模式

《如何安全地使用密码》

### 操作模式们

> 有很多操作模式，比如：
  - 电子密码本ECB (electronic codebook mode)
  - 密码分组链接CBC (cipher block chaining)
  - 密码反馈CFB (cipher feedback)
  - 输出反馈OFB (output feedback)
  - 计数器CTR (counter)
  - 分组链接BC
  - 带有非线性函数的输出反馈模式OFBNLF

##### 电子密码本ECB

<img src="./信息安全引论.assets/image-20251016154000735.png" alt="image-20251016154000735" style="zoom:50%;" />

- 优势：简单有效；可以并行实现。
- 缺点：不能隐藏明文的模式信息，相同明文=相同密文，同样信息多次出现造成泄漏；对明文的主动攻击是可能的；信息块可被替换、重排、删除、重放。
- 误差传递：1密文块损坏--> 1明文块损坏
- 适合于传输短信息

##### 密码分组链接CBC

<img src="./信息安全引论.assets/image-20251016154215410.png" alt="image-20251016154215410" style="zoom:43%;" />

- 需要共同的初始化向量IV
- 优势：能隐藏明文模式信息；对明文的主动攻击是不容易的；信息块不容易被替换、重排、删除、重放。
- 缺点：无法并行
- 误差传递：1密文块损坏--> 2明文块损坏

##### 密码反馈CFB

<img src="./信息安全引论.assets/image-20251016154610460.png" alt="image-20251016154610460" style="zoom:33%;" /><img src="./信息安全引论.assets/image-20251016155817313.png" alt="image-20251016155817313" style="zoom:33%;" />

- 误差传递：1密文块损坏--> 多个明文块损坏（看b/s值）。
- 初始化向量IV需要每次都不一致，不然容易出现相同明文-密文对。其余同上。

##### 输出反馈OFB

<img src="./信息安全引论.assets/image-20251016155723665.png" alt="image-20251016155723665" style="zoom:33%;" /><img src="./信息安全引论.assets/image-20251016155743399.png" alt="image-20251016155743399" style="zoom:33%;" />

- 误差传递：1密文块损坏--> 1明文块损坏
- 对明文的主动攻击是可能的（可以直接在密文上修改bit即修改了对应的明文bit），安全性较CFB差。

##### Counter (CTR)

<img src="./信息安全引论.assets/image-20251016161135535.png" alt="image-20251016161135535" style="zoom:43%;" />

- 优势：可以并行实现，可以预处理，适用于高速网络，可以随机访问加密的数据分组；隐藏了明文模式
- 误差传递：1密文块损坏--> 1明文块损坏
- 对于每次加密，需要使用不同的密钥的计数器值

### 分组填充

不是分组长度整数倍的报文就需要填充。因为想自动处理，所以通常总是要填充的。

##### RC5的填充方式

读最后一个字节，读出来是多少就去掉最后多少个字节。eg. 如果有8字节的填充，则最后8字节每个字节都为00001000。

**密文挪用（CTS模式）**：cipher text stealing

- 想要保持密文和明文长度一致，于是把最后一个完整块的密文的后半部分砍掉↓

  <img src="./信息安全引论.assets/image-20251018164908405.png" alt="image-20251018164908405" style="zoom:33%;" />

- 可以通过以下方法还原：*X 是从完整密文块中截取的 “补位片段”*

  <img src="./信息安全引论.assets/image-20251018165602223.png" alt="image-20251018165602223" style="zoom:43%;" />

### 其他加密需求

#### 存储数据加密

存储数据的加密与传输数据的加密要求不同，P1619标准的设计要求如下:

1. 攻击者可以随意获取密文
2. 数据的布局不能改变，加密后的数据和明文数据有相同大小
3. 授权用户可以定长分组为单位访问数据，分组之间独立
4. 加密以16-byte的分组为单位，分组相互独立
5. 除数据在数据集中的位置外，不使用其他元数据
6. 不同位置的相同明文加密为不同的密文，但在写同一位置时，总写为相同密文
7. 一个与标准兼容的加密设备加密的数据，可以用另一个与标准兼容的设备解密

##### 基础思想

**可调分组密码（Tweakable Block Cipher）**：引入了一个额外的参数 “调节因子（Tweak，图中的 T~j~ ）”，使得相同的明文和密钥在不同调节因子下能产生不同的密文。（Hash function：将调节因子(比如位置描述)映射成随机数）

<img src="./信息安全引论.assets/image-20251018170636871.png" alt="image-20251018170636871" style="zoom:43%;" />

##### XTS-AES模式

<img src="./信息安全引论.assets/image-20251018171116462.png" alt="image-20251018171116462" style="zoom:33%;" /><img src="./信息安全引论.assets/image-20251018171130305.png" alt="image-20251018171130305" style="zoom:33%;" />

1. 生成调整因子 T：输入 128 位[调整值 i](i为时变值)，用密钥 Key2 对其进行 AES 加密，再与有限域  GF(2^{128})  中的本原元 [α^j^](j 是数据单元内分组的序号，为计数器) 进行乘法运算，得到调整因子 T。

2. 处理明文分组  Pj ：将明文分组 (Pj) 与调整因子 T 进行异或运算，得到中间结果 PP。

3. AES 加密与最终密文生成

   

#### 保留格式加密

保留格式加密 Format-Preserving Encryption (FPE) 指的是一种输出密文保留明文格式的加密技术。<img src="./信息安全引论.assets/image-20251018171916727.png" alt="image-20251018171916727" style="zoom:43%;" />

- 应用场景：
  1. 数据库：采用字符串格式的字段不能存储二进制格式的密文
  2. 高效传输：FPE算法加密的数据可以有效压缩
  3. 数据脱敏：是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。如身份证号、手机号、卡号、客户号等个人信息都需要进行数据脱敏。
- 要求：
  1. 数据类型相同、长度相同（能处理各种明文长度）
  2. 可适用于各种字符和数字类型
  3. 对于非常短的明文也具有强安全性（安全强度与AES相当）

算法包括：openssl，Crypto++，Criptix，Criplib，PGP SDK



## 六、流密码

流密码的基本思想是利用密钥k产生一个密钥流z=z0z1…zm，用明文串异或密钥流的方式来加密明文串。*流密码的关键不是 “是否分块”，而是加密过程是否基于 “密钥流 + XOR”—— 无论密钥流是逐比特生成还是逐块生成，只要最终通过 “密钥流块 XOR 明文块” 得到密文，就属于流密码的工作模式* `使用密码反馈CFB、输出反馈OFB和计数器CTR模式即将分组密码转换为了流密码`

- 流密码特点：加密速度快、资源占用低、安全性有缺陷
- 适用场景：特定轻量化或高速场景。

### 同步流密码

同步流密码：密钥流的生成与明文、密文完全独立，仅依赖初始密钥和初始向量（IV），且加密和解密端需保持 “同步” 才能正确还原数据。

构成：（P,C,K,L,E,D) 和函数f。即P明文空间、C密文空间、K密钥空间、L密钥流字母表、f[密钥流生成器](使用密钥K作为输入，产生无限的密钥流z=z0z1…zi∈L,i≥1)、E加密算法集、D解密算法集。

#### 设计流密码的准则

1. 加密序列的周期要长
2. 密钥流应该尽可能地接近于一个真正的随机数流的特征.
3. 为防止强力攻击，密钥应该足够长。不小于128位。

#### RC4

RC4是一个密钥大小可变的序列密码，于1987年由[Ron Rivest](RSA算法中的R) 开发，是目前应用和影响力都最为广泛的一种流密码算法。是一个面向字节的流密码，对线性和差分分析免疫，密钥长度从1字节到256字节，或8比特到2048比特可变。所需要代码少。由于RC4是流密码，必须避免重复使用密钥。

##### 原理

摸球模型：256个外形完全一致分别标有0，1,…,255的球放在一个口袋中，将所有球充分混合后，每次随机取一球。

```c++
//第一阶段：S盒初始化
for i=0 to 255 do
    S[i]=i;
    T[i]=K[i mod keylen] //将K赋给T
j=0;
for (i = 0 to 255)
    j = (j + S[i] + T[i]) mod 256
    Swap S[i] and S[j] //充分混合
//第二阶段：密钥流的生成
i,j=0
while(true)
	i = (i + 1) mod 256
    j = (j + S[i]) mod 256
    Swap S[i] and S[j] //希望每取一次球，就对袋子中的球“搅和一把”
    t = (S[i] + S[j]) mod 256 //希望取出的第t个球是随机取出的；
    k = S[t]
    //然后k与明文异或产生密文，与密文异或产生明文
```

---



# Lecture 4. 公钥密码

## 一、公钥密码的基本思想

##### 对称算法的不足

1. 密钥管理量的困难：两两分别用一个密钥的话，则n 个用户需要C(n,2)=n(n-1)/2 个密钥。
2. 密钥传递：密钥必须通过某一信道协商，对这个信道的安全性的要求比正常的传送消息的信道的安全性要高。
3. 数字签名的问题：传统加密算法无法实现抗抵赖的需求。

##### 希望公钥密码满足

1. 加密与解密由不同的密钥完成。KU: public key. KR: private key.

   加密: X -> Y: Y = E~KU~ (X) 

   解密: Y -> X: X = D~KR~(Y) = D~KR~(E~KU~(X)

2. 产生一对密钥是计算可行的

3. 已知公钥和明文，产生密文是计算可行的

4. 接收方利用私钥来解密密文是计算可行的

5. 对于攻击者，利用公钥来推断私钥是计算不可行的

6. 已知公钥和密文，恢复明文是计算不可行的

7. 两个密钥中任何一个都可以用作加密而另一个用作解密（不是必须的）

   X = E~KU~(D~KR~(X) = D~KR~(E~KU~(X)

即想寻找陷门单向函数。

##### 陷门单向函数

单向陷门函数是满足下列条件的函数f：

1. 给定x，计算y= f~k~(x) 是容易的
2. 给定y，计算x 使 x=f~k~^-1^(y) 是不可行的。
3. 存在k，已知k 时，对给定的任何y，若相应的x 存在，则计算x=f~k~^-1^(y) 是容易的。

##### 应用方法

每个用户拥有自己的密钥对(KU, KR）

1. 保密：Alice给Bob发消息，用Bob的公钥进行加密，Bob用私钥解密。
2. 数字签名：Alice要保证这是自己发的消息，就用自己的私钥加密，别人可以通过Alice的公钥来验证。
3. 密钥交换：在公用信道上商议出密钥



## 二、公钥数学基础

#### 复杂性

##### 算法复杂性

一般地，一个可以在多项式时间内解决的问题被认为是可解的，而任何比多项式时间更长的时间，尤其是指数时间，被认为是不可解的。指数时间：O(t^h(n)^))，其中t 是一个常数，h(n) 是一个多项式。

##### 问题复杂性

图灵机是一种具有无限读写能力的有限状态机，并且可以做无限的并行操作。图灵机分为确定型和非确定型两种。确定型是指图灵机的每一步操作的结果是唯一确定的。所谓非确定型图灵机的每一步操作结果及下一步操作都有多种选择，不是唯一确定的。一个问题的复杂性由在图灵机上解此问题的最难实例所需要的最小时间与空间决定。即解此问题的最有效的算法所需的时间与空间来度量。

- 在确定型图灵机上用多项式时间可解的问题，称为易处理问题。易处理判定问题的全体称为确定型多项式时间可解判定问题类，记为P。*验证容易*

- 在非确定型图灵机上用多项式时间可解的判定问题，称为非确定型多项式时间可解判定问题，简称NP 问题。NP 问题的全体称为非确定型多项式时间可解判定问题类，记为NP 。求解分为猜测和验证阶段。*求解不容易*

- 还没有人证明P = NP 或 **P != NP**

  - 如果 “P=NP” 成立：意味着现在看起来很难的 NP 问题（比如密码破解、物流最优路径规划），其实都存在未被发现的多项式时间算法，未来能被轻松解决。
  - 如果 “P≠NP” 成立：意味着 NP 问题中存在一些问题，它们的 “验证” 和 “求解” 效率有本质差距 —— 就算能快速验证答案，也找不到快速求解的方法，这也是目前学术界更倾向的猜想。 

- 背包问题，又称子集和问题（subset sum）属于NP 问题。

  

#### 公钥密码基于的数学难题

- 背包问题

- 大整数分解问题（The Integer Factorization Problem，RSA 体制）

- 离散对数问题

  - 有限域的乘法群上的离散对数问题（The Discrete Logarithm ProblemProblem，ElGamal 体制）

  - 定义在有限域的椭圆曲线上的离散对数问题（The Elliptic Curve Discrete Logarithm ProblemProblem，类比的ElGamal 体制）

    

### 一些数学定理们

#### 中国剩余定理

<img src="./信息安全引论.assets/image-20251023153759458.png" alt="image-20251023153759458" style="zoom:40%;" />



#### Fermat定理（费马小定理）

- p是素数，a是整数且不能被p整除，则 **a^p-1^ = 1 mod p**

- 推论：p是素数，a是任意整数，则 a^p^ = a mod p

  <img src="./信息安全引论.assets/image-20251023154218001.png" alt="image-20251023154218001" style="zoom:40%;" />

  eg. 计算 7^201^ mod 11

  *由定理得 7^10^ = 1 mod 11,* *则 7^201^ = (7^10^)^20^* * *7 = 7 mod 11*

  

#### 欧拉定理

##### 欧拉函数

欧拉函数Φ(n)定义为小于n且与n互素的正整数个数。

- 若n为素数，Φ(n)显然为n-1

- 若n可以质因数分解，则Φ(n)=n * Π(1-1/质因数)

  eg. n = 20 = 2 * 2 * 5, Φ(n) = 20 * 1/2 * 4/5 = 8，即20有8个不含2也不含5的数，即有8个互素的数。

  特别的，当n = p * q 时 (p,q为素数)，有Φ(n) = (1-p) * (1-q)

##### 欧拉定理

若a与n互素，则 **a^Φ(n)^ = 1 mod n**

推论：m^k(p-1)(q-1)+1^ = m mod n，k为任意整数，[m为任意小于n非负整数](可以证明m为p或q时也成立)

<img src="./信息安全引论.assets/image-20251027101301629.png" alt="image-20251027101301629" style="zoom:40%;" />



#### 有限域上的离散对数

- 如果 a 是素数 p 的原根，则数 a mod p, a^2^ mod p，…，a^p-1^ mod p 是不同的并且包含1 到 p-1 的整数的某种排列，则称为一个**有限循环群**。
- 设G是一个阶为p的有限循环群，g是它的生成元，则G的元素可表示为： G = \{1, g, g^2^, ..., g^p-1^} ，由此可见，对G的任何元素y，一定存在某一个正整数x∈(0, p-1) ，使得 y = g^x^ mod p ，这里，称整数x是群G上元素y关于生成元g的**离散对数**。
- 离散对数难题（Discrete Logarithm Problem，DLP）是：在G上，对于方程 y = g^x^ mod p 
  - 已知g，x，p，计算y是容易的，
  - 已知y，g，p，计算x是困难的。
- 密码学中常用的主要有三个群的离散对数
  - 有限域 GF(p) 的乘法群
  - 有限域 GF(2^n^) 上的乘法群
  - 有限域F上的椭圆曲线群



## 三、经典公钥密码算法

### Diffie-Hellman 密钥交换算法

只能用于交换密钥。算法的安全性依赖于有限域上计算离散对数的难度。

##### 算法

1. 双方选择素数p以及p的一个原根a
2. 用户A随机选择一个随机数 r~a~，计算 a^ra^ mod p = m~a~
3. 用户B随机选择一个随机数 r~b~，计算 a^rb^ mod p = m~b~
4. 双方保密r值，将取模得到的m值交换
5. 用户A计算出m~b~^ra^ mod p
6. 用户B计算出m~a~^rb^ mod p
7. 双方获得共享密钥 a^rxrb^ mod p

##### 中间人攻击

中间来个用户O，使得A和O商议出了一个密码，O和B商议出了一个密码。但是O永远必须实时截获并冒充转发，否则会被发现。



### Merkle-Hellman 公钥算法（基于背包问题）

这是一个NP 完全问题，因为对于给定的子集易于验证其和是否为S 。然而，找到一个子集使其和为S要困难得多，有2^n^个可能的子集。因此可以把子集作为密钥，明文作为{0, 1, 0, 0, 1, ...}，S为密文。奥妙在于有两类背包，一类可以在线性时间内求解，另一类则不能。所以公开密钥使用难解的背包问题，私钥使用易解的背包问题。

##### 易解的背包问题

超递增背包：每个元素大于之后所有的元素的和。
Sol. 从最大的ai开始，如果S 大于这个数，则减去ai , 记xi为1，否则记xi为0。即可求解。

##### 转换背包

选择一个整数 m > 所有背包的和，选择一个和m互素的整数w，即可把所有 a~i~ 转换为 a~i~ * w mod m，得到难解的背包问题。

##### 算法

1. 加密：使用难解背包公钥把明文的01串转换为S。
2. 解密：计算S * w^-1^ mod m，即可得到在简单背包下的和，然后求解简单背包即可。

##### 意义

是第一个推广的公钥加密算法。在实践过程中，大多数的背包方案都已被破解，或者证明存在缺陷，但它表示了如何将NP 完全问题用于公开密钥算法。



### RSA 算法

应用最广泛的公钥加密算法，使用欧拉定理。

#### 算法

- 考虑明文 m^1+k(p-1)(q-1)^ = m mod n，n = pq。*[欧拉定理]*

- 公钥为 {n, e}，e为一个与(p-1)(q-1)互素的数。

  加密：c = m^e^ mod n

- 私钥为 {p, q}，可以求得 e^-1^ mod (p-1)(q-1)，则有 e^-1^e = 1 + k(p-1)(q-1)。

  解密：m = c^e'^ = m^e'e^ = m^1+k(p-1)(q-1)^ = m mod n

- 也可用于签名：

  签名：s = m^e'^ mod n

  验证：m = y^e^ = m^e'e^ = m mod n

一般，使用1e200数量级的p,q，n的二进制位数至少为2048位。为了提高加密速度，通常取e为特定的小整数，如3或2^16^+1。*此时加密速度一般比解密速度快十倍以上*

>为了抵抗现有的整数分解算法，对p和q还有如下要求：
>(1) |p-q| 很大，通常 p 和 q 的长度相同；
>(2) p-1 和 q-1 分别含有大素因子 p~1~ 和q~1~
>(3) P~1~-1 和 q~1~-1 也分别含有大素因子
>(4) p+1 和 q+1 也分别含有大素因子



#### 实现中的问题

##### 如何快速计算幂

通过快速幂实现logn算法。

##### 如何找到两个大素数

因为试除法太慢了，所以采用统计素性检测（所有素数都满足的特性，但不充分）

1. 基于费马定理：p是素数，a是整数且不能被p整除，则 a^p-1^ = 1 mod p。则可以随机选取多个基进行检测。
2. 二次探测定理：x^2^ = 1 mod p 的解一定是 1 mod p 和 -1 mod p<img src="./信息安全引论.assets/image-20251101162040102.png" alt="image-20251101162040102" style="zoom:40%;" />

**Miller-Rabin素性检测**：运用上面两条定理。

1. 现在我们要检测n，因为(n-1)是偶数，所以可表示为 2^k^ * q（q 为奇数）
2. 选一个整数a，0<a<n-1，计算幂序列模n的余数a^q^，a^2q^，a^4q^……，$a^{2^{k-1}q}$
3. 费马定理：如果满足 a^q^ mod n = 1 (因为a^n-1^ = $a^{2^{k}q}$ = (a^q^)^2k^ = 1 mod n)，则可能是素数。
4. 如果不满足3，那么使用二次探测定理：首先根据费马定理，$a^{2^{k}q} = a^{n-1} =$1 mod p。所以根据二次探测定理，一定满足$a^{2^{k-1}q}$ = ±1 mod p (因为$a^{2^{k-1}q}$是$a^{2^{k}q}$的平方根)。如果它余-1则满足要求，如果它余1则可以往前递推直到第一个。又因为第一个不余1，所以如果是素数，则序列中一定存在一个余-1的。
5. 如果满足3或4，则可能是素数，继续换个数测测看。多测几次都成立的话，是素数的可能性就很大了。

有性质：若n是一个奇合数，则在区间0<b<n 中，至多有25%个b, 使得用b测不出来n不是素数（此时称n为以b为基的强伪素数）。事实上，如果n≠9, 则至多有Φ(n)/4 个b, n是以b为基的强伪素数。Φ(n)是欧拉函数。

随机选取大约用ln(N)/2 的次数，如要找一个2^200^ 数量级的数， ln(2^200^ )/2=70



#### 对RSA的选择密文攻击

攻击思想：诱骗签名

回顾 RSA：加密 c = m^e^ mod n，签名 s = m^e'^ mod n。公钥{n, e}, 私钥{p, q}, n=pq。

##### eg1. 套取信息

[E][eavesdropper]监听A的通信，收集由A的公开密钥加密的密文c，想知道消息的明文m.

1. E随机选一个数r, 将r^e^c发给A让A签名
2. 则可以得到 s = (r^e^c)^e'^ = r * c^e'^ = r * m
3. 则乘以一个r的逆元即可得到原明文~

##### eg2.

如果E想让A对m3文件签名，而E知道m3 = m1 * m2，则可以让A对m1,m2签名，乘起来即可得到对m3的签名。

*所以不要用RSA对陌生人的随机文件签名！*



#### 对RSA的公共模攻击

一种可能的RSA实现方法是给每个人相同的n，但指数d和e不同。

问题：如果相同的消息曾用两个不同的指数加密，而这两个指数是互素的，则明文可以不用任何一个解密密钥来恢复。

- 令m为明文消息，两个加密密钥为e1，e2，两个密文消息为c1，c2。c1=m^e1^ mod n，c2=m^e2^ mod n。
- 由于e1 和e2 互素，所以可以用扩展的Euclid 算法找到r,s 使 re1+se2=1
- r和s会有一个是负数。负数无法直接幂运算，所以进行一个转换：假设r 是负数，用扩展Euclid算法计算c1的逆元，则 (c1^-1^)^-r^ * c2^s^ =m^re1+se2^ = m mod n，即可得到明文。

*所以不要让一群用户共享一个模n！*



#### 对RSA的小加密指数攻击

因为对于同一个加密指数e和同一个明文m，如果得到多组密文模数对，则可通过中国剩余定理求解出 m^e^
$$
c_1 = m^{e}  \ mod \ p_1 \\
c_2 = m^{e}  \ mod \ p_2 \\
c_3 = m^{e}  \ mod \ p_3 
$$
如果e过小，则可以从m^e^轻松解出m



#### 对RSA的小解密指数攻击

如果e'太小，直接穷举攻击即可。所以应选择一个大的e'值。



#### 对RSA的定时攻击

基于加密程序运行时间的不一致性，可以根据加密时间长短逐个确定m的二进制位是否为1（是否执行了操作）

<img src="./信息安全引论.assets/image-20251101185328408.png" alt="image-20251101185328408" style="zoom:33%;" />

##### sol.

1. 使用恒定的幂运算时间
2. 增加随机延迟
3. 盲化：收到密文后，给密文乘上一个随机数r^e^，再破解，再乘以r^-1^，得到原文。



### ElGamal算法

基于有限域上离散对数的计算难度。

#### 算法

1. 选取大质数p，以及p的原根g。原根：g^Φ(p)^ = 1 mod p（只要互素即可）
2. 随机选取指数i，计算 g^i^
3. 公钥为 {p, g, g^i^}，私钥为 {i}
4. 加密：随机选择一个指数r，传递 c1 = g^r^, c2 = g^ir^ * m
5. 解密：计算 c1^-i^ * c2 = g^-ir^ * g^ir^ * m = m

*信息有扩张：传递了两倍明文的长度*

#### 安全性

需要使用不同的随机数r来加密。假设使用相同的r，得到 (c1, c2), (c1', c2')，则 c2/c2' = m/m'，则如果一个明文已知，就可以知道另一个明文。



### 椭圆曲线密码

基于有限域的椭圆曲线上的离散对数问题。

#### 算法

- 椭圆曲线：y^2^= x^3^ + ax + b

  <img src="./信息安全引论.assets/image-20251102110959904.png" alt="image-20251102110959904" style="zoom:25%;" /><img src="./信息安全引论.assets/image-20251102111019269.png" alt="image-20251102111019269" style="zoom:25%;" />

- 一次运算：Q和R连线，相交，对称，得到-P1。Q和Q自己也可以做这个运算（切线）。记为"+"。

- 公钥：{基点，运算k次后得到的新点}。私钥：{k}。

- 思想：知道运算多少次后得到结果很容易，只知道结果想知道运算了多少次很困难。

- 加密思想（不要求）：

  <img src="./信息安全引论.assets/image-20251102112238142.png" alt="image-20251102112238142" style="zoom:25%;" />

对椭圆曲线研究的时间短。椭圆曲线密钥长度短，速度快，可以用于加密、签名、密钥传递。



### 总结

安全性比较：要达到相同破解计算量，各算法需要的密钥长度↓ *加密的各个环节的密钥强度需要一致，不然会攻击最弱的那个*

<img src="./信息安全引论.assets/image-20251030162927415.png" alt="image-20251030162927415" style="zoom:50%;" />

公钥算法加密解密速度慢，所以一般用来传递密钥，然后用对称加密算法加密信息。

---



# Lecture 5. 消息鉴别

## 零、Intro

> 数据完整性：（1）未被未授权篡改或者损坏。（2）数据是真实的和不可否认的，数据的发送方和接收方都不能否认其处理了该信息。
>
> 系统完整性：系统未被非授权操纵，按既定的功能运行。
>
> 真实性：确认实体是它所声明的。适用于用户、进程、系统、信息等。

**消息鉴别：证实收到的消息 (1)来自可信的源点 (2)未被篡改**

一个简单模型：

<img src="./信息安全引论.assets/image-20251030165153813.png" alt="image-20251030165153813" style="zoom:40%;" />

鉴别编码器和鉴别译码器可抽象为鉴别函数。

鉴别函数一般分为三种：

1. 消息加密函数(Message encryption): 用完整信息的密文作为对信息的鉴别。

2. 散列函数(Hash Function): 一个散列函数以一个变长的报文作为输入，并产生一个固定长度的散列码，有时也称报文摘要，作为输出。是一个公开的函数。

3. 消息鉴别码MAC (Message Authentication Code): 公开函数+密钥产生一个固定长度的值作为鉴别标识

   

## 一、消息加密函数

#### 对称加密

提供保密，提供鉴别，不提供签名（因为共享密钥无法实现身份区分）

##### 差错控制

1. 内部差错控制：在加密之前计算校验和。
2. 外部差错控制：在加密之后计算校验和。（这个比较擅长检验差错，因为内部差错控制动一点解密后就会动很多，就不好说了）

<img src="./信息安全引论.assets/image-20251110202401278.png" alt="image-20251110202401278" style="zoom:50%;" />



#### 公钥加密

- 用公钥加密：提供保密（公钥加密完后只有私钥能解）。
- 用私钥加密：提供鉴别，提供签名。



## 二、密码学散列函数

因为加密函数不是专门用来鉴别的，所以效率低，所以发明出密码学散列函数。

#### 散列函数的概念

对任意长度消息输出固定长度的散列值（称为消息摘要 Message Digest）。这个散列值是消息M的所有位的函数，并提供错误检测能力：消息中的任何一位或多位的变化都将导致该散列值的变化。

又称为：哈希函数、数字指纹（Digital finger print) 、压缩（Compression) 函数、紧缩（Contraction ）函数...

一般而言，对散列后的消息摘要进行加密传递，即可解密后进行验证。

##### 好处

- 提高数字签名的速度
- 无需泄露签名所对应的消息，可将签名泄露，如对消息x 的签名是y=Sig(z)，其中z=h(x), 可将 z,y 公开，而保密x。
- 可将签名变换和加密变换分开，可以在OSI 的不同层提供消息的完整性和机密性。

##### 其他应用

1. 生成单向口令文件（eg. 系统验证用户身份）

2. 用于入侵与病毒检测（验证软件的消息摘要）

3. 用于构建随机函数和伪随机函数

   

#### 基本用法

一看就懂的一堆。eg. 加密消息摘要、消息和消息摘要一起加密、约定一个秘密值参与消息摘要计算、......

##### 约定一个秘密值参与消息摘要计算

<img src="./信息安全引论.assets/image-20251112164918114.png" alt="image-20251112164918114" style="zoom:50%;" />

好处：不需要加密算法。（authentication：真实性，没有被他人篡改）

- 加密软件很慢
- 加密硬件的开销很大
- 加密是对大长度数据进行优化的
- 加密算法可能受专利保护、可能受出口的限制...



#### 散列函数的要求

##### 安全要求

1. 在计算量上无法找到两个散列结果一致的消息，不然可以视作对另一消息签了名。

   所以定义**弱无碰撞**：对给定消息x，在计算上几乎找不到异于x的x'，使h(x)=h(x’) 。满足要求的散列函数称为*抗第二原像攻击（抗弱碰撞攻击），Second preimage resistant (weak collision resistant)*。

   **强无碰撞**：对任意消息x，在计算上几乎找不到异于x的x'，使h(x)=h(x’)。满足要求的散列函数称为*抗强碰撞攻击，Collision resistant (strong collision resistant)*。

2. 不能让攻击者拿到消息摘要后反算出秘密值s，所以要求散列函数是**单向**的：计算h的逆函数在计算上不可行。满足要求的散列函数称为*抗原像攻击，Preimage resistant (one-way property)*

不同应用中有不同程度的安全要求：

<img src="./信息安全引论.assets/image-20251112170914135.png" alt="image-20251112170914135" style="zoom:35%;" />

##### 其他要求

1. h 可以作用于一个任意长度的数据块
2. h 产生一个固定长度的输出；
3. 对任意给定的x, h(x)计算相对容易，无论是软件还是硬件实现。
4. h的输出满足伪随机性测试标准

##### 无碰撞

根据生日悖论的结论，可以知道当人数>sqrt(天数)时，生日碰撞的概率>50%

假如散列码为m位，即2^m^种输出

- 弱无碰撞：只需要2^m-1^次攻击，使碰撞的概率>50%。
- 强无碰撞：只需要2^m/2^次攻击，使碰撞的概率>50%。

eg. 假如散列码长度位64位，则A可以构造两份合同，各做>32处微小变化↓，有很大可能可以找到一个版本使得两份合同哈希码一致，即可让B签名后进行替换。（*哈希值是A可以算的，B使用私钥对哈希值签名，A无法仿造签名*）

<img src="./信息安全引论.assets/image-20251112173409601.png" alt="image-20251112173409601" style="zoom:33%;" />



#### 散列函数的构造

- 基于数学难题的构造方法：计算速度慢，不实用
- 利用对称密码体制来设计Hash：不实用
- 直接设计：好！

##### MD结构

由Merkle 于1989年提出，Ron Rivest于1990 年提出MD4，几乎被所有hash函数使用。

<img src="./信息安全引论.assets/image-20251112180153089.png" alt="image-20251112180153089" style="zoom:40%;" />

- IV = initial value初始值
- CV = chaining value
- Yi = 第i个分组，依次送进压缩函数加工，压缩在一起。
- f = compression algorithm (压缩算法）
- b = length of input block(输入块的长度）

##### 海绵结构（SHA3）

<img src="./信息安全引论.assets/image-20251112181709317.png" alt="image-20251112181709317" style="zoom:50%;" />

#### 散列函数重要算法

**MD5**（已破解，输入任意长度，**512位块处理，输出128位**），**SHA1**（已停用，输入小于2^64-1，**512位块处理，输出160位**），RIPEMD-160，SHA2，**SHA3**-512（输出512位，即64字节；**海绵结构**），SM3（中国）





## 三、消息鉴别码MAC

#### 安全性

使用一个密钥生成一个固定大小的小数据块，并加入到消息中，称MAC， 或密码校验和（cryptographic
checksum）。MAC函数类似于加密函数，但不需要可逆性。因此在数学上比加密算法被攻击的弱点要少。接收者可以确信消息M 未被改变；来自所声称的发送者；如果消息中包含顺序码，则接收者可以保证消息的正常顺序。

> [!TIP]
>
> MAC和Hash的区别
>
> - MAC：依赖密钥，确认消息完整地来自合法发送方，安全性依赖于对称密钥的保密性。只有持有相同密钥的通信方，才能正确生成或验证 MAC。如果密钥泄露，MAC 的安全性完全丧失。
> - Hash：是一种无密钥的单向函数，将任意长度的消息映射为固定长度的哈希值，用于确认消息未被篡改。安全性依赖于哈希算法本身的抗碰撞性。它不需要密钥，任何人都可以计算同一消息的哈希值。



#### 基于分组密码的CMAC

##### CBC-MAC

<img src="./信息安全引论.assets/image-20251112195339855.png" alt="image-20251112195339855" style="zoom:40%;" />

分组加密+异或前一组结果，取最后结果的前m位。

缺陷：要求信息长度固定为b的n倍；可以经过伪造伪造出比原信息更长但MAC一致的情况。（假设T=MAC(K,X)，则 X||(X xor T) 的MAC 依然是T。*前半部分X加密完得到T，T xor X xor T就是X，所以最终还是得到T*）

##### CFB-MAC

<img src="./信息安全引论.assets/image-20251115191211072.png" alt="image-20251115191211072" style="zoom:60%;" />

CFB后取最后结果的前m位。

##### CMAC

<img src="./信息安全引论.assets/image-20251115191658992.png" alt="image-20251115191658992" style="zoom:40%;" />

支持任意长度消息。

- CBC-MAC：消息分组直接异或前一输出后加密，最终输出截取为 MAC，无额外密钥调整。
- CMAC：
  - 当消息长度是分组倍数时，最后一个分组会异或一个预计算的密钥 \(K1) 后加密。
  - 当消息长度不是分组倍数时，最后一个分组会先填充（如补`10...0`），再异或另一个预计算的密钥 \(K2)后加密。
  - K1K2由轮函数生成。

##### 基于分组密码的整体问题

用加密算法来检验真实性代价太大了。



#### 基于Hash函数的HMAC

> 设计目标：
>
> 无需修改地使用现有的散列函数
> 当出现新的散列函数时 要能轻易地替换
> 保持散列函数的原有性能不会导致算法性能的降低
> 使用和处理密钥的方式简单
> 对鉴别机制的安全强度容易分析 与hash 函数有同等的安全性

<img src="./信息安全引论.assets/image-20251115192614108.png" alt="image-20251115192614108" style="zoom:45%;" />

流程可以理解为：用key异或ipad成为si，si粘在信息前面一起hash。再用key异或opad成为so，再粘到刚刚的结果后面再hash一次得到HMAC。





## 四、伪随机数生成器

PRNG：Pseudo Random Number Generator

取 Hash(seed) 得到的结果的前n位，seed+=1或seed=Hash(seed)，准备生成下一个。

---







# Lecture 6. 数字签名

## 一、对签名的攻击

##### 对签名方案的攻击模型

1. 唯密钥攻击（key only attack attack）：攻击者Oscar拥有Alice 的公钥
2. 已知消息攻击（know message attack attack）：Oscar拥有一系列以前由Alice签名的消息和签名。
3. 选择消息攻击：Oscar请求Alice对一个消息列表签名。

##### 攻击目的

1. 完全破译（total break）：攻击者Oscar可以确定Alice的私钥
2. 选择性伪造（selective forgery)：攻击者能以某一不可忽略的概率对一则选择的消息产生一个有效的签名。该消息不是以前Alice曾经签名的消息
3. 存在性伪造（existential）：攻击者至少能够为一则消息产生一个有效的签名，该消息不应该是以前Alice 曾经签名的消息。

> 示例回顾
>
> - 唯密钥攻击的存在性伪造：Oscar 能通过对某一y 计算x=y^e^ 伪造一个Alice对随机消息x的签名，因为y= y^ed^。即正向算出来了然后声称是Alice签的名。
> - 已知消息攻击的存在性伪造：如果Osacr 拥有Alice 对消息x1, x2的签名分别是y1和y2，则Oscar 可伪造Alice 关于消息x1x2的签名y1y2。
> - 选择消息攻击的选择性伪造：假定Oscar 要伪造消息x的签名，Oscar 请求A对x1, x2签名，签名结果分别是y 1 ,y 2 。 y 1 y 2 mod n 是消息x 1 x 2 mod n 的签名。



## 二、数字签名分类

- 以验证方式分
  - 直接数字签名direct digital signature：只有通信双方参与。
  - 仲裁数字签名arbitrated digital signature：有第三方可以参与验证。*通常的做法是所有从发送方X到接收方Y的签名消息首先送到仲裁者A，A将消息及其签名进行一系列测试，以检查其来源和内容，然后将消息加上日期并与已被仲裁者验证通过的指示一起发给Y。所有的参与者必须极大地相信这一仲裁机制工作正常*。
- 计算能力分
  - 无条件安全的数字签名
  - 计算上安全的数字签名
- 以可签名次数分
  - 一次性的数字签名（理论上可以做到无条件安全）
  - 多次性的数字签名
- 具有特殊性质的数字签名



## 三、数字签名方案

##### 签名与加密同时需要时

推荐先签名后加密。如果先加密后签名，则需要公开对称密钥来验证签名，以及会有其他安全问题。



#### 回顾

可以使用RSA、ElGamal、椭圆曲线进行数字签名



#### Schnorr 数学签名方案

基于离散对数。

<img src="./信息安全引论.assets/image-20251115200639918.png" alt="image-20251115200639918" style="zoom: 33%;" />



#### DSS/DSA

数字签名标准，基于离散对数。

DSS（Digital signature Standard Standard），DSA (Digital signature algorithm)

<img src="./信息安全引论.assets/image-20260108084542138.png" alt="image-20260108084542138" style="zoom:50%;" />

<img src="./信息安全引论.assets/image-20260108084601975.png" alt="image-20260108084601975" style="zoom:50%;" />

##### 特点

- DSS的签名比验证快得多
- DSS不能用于加密或者密钥分配
- 若p为512位，q为160位，则r和s为两个160位，即签名长为320位
- 验证依赖于r，但r不依赖于消息，接收方可以利用收到的消息、签名及全局参数来恢复r
- 可提前计算r，r=( g^k^ mod p)mod q

##### 问题

1. 若对0签名，会泄露密钥。$$ s = 0 = k^{-1}\left[H(m) + xr\right] \mod q $$ 那么 $$x = -H(m)r^{-1} \mod q $$

2. 不能泄露随机数k，否则可以由$$ s = k^{-1}\left[H(m)+ xr\right] \mod q$$求出$$x = sk-H(m)r^{-1} \mod q $$

3. 不要用同一个k签两个不同的消息。
   $$
   \begin{align*} &\text{设用同一随机数 } k \text{ 对消息 } m_1 \text{ 和 } m_2 \text{ 签名，得到：} \\ s_1 &= k^{-1}\left[H(m_1) + x r\right] \mod q \\ s_2 &= k^{-1}\left[H(m_2) + x r\right] \mod q \\ \\ &\text{两式相减消去 } x r \text{：} \\ s_1 - s_2 &= k^{-1}\left[H(m_1) - H(m_2)\right] \mod q \\ \\ &\text{两边乘 } k \text{ 再乘 } (s_1 - s_2)^{-1} \text{，可得 } k \text{：} \\ k &= \left[H(m_1) - H(m_2)\right] \cdot (s_1 - s_2)^{-1} \mod q \\ \\ &\text{代入任意一个签名式，即可求出私钥 } x \text{：} \\ x &= \left(s_1 k - H(m_1)\right) \cdot r^{-1} \mod q \end{align*}
   $$



#### RSA-PSS

probabilistic signature scheme

引入随机数，使得同一则消息签名两次也不一样。



#### 一次性数字签名

一次性签名方案是指仅能对一条消息安全签名的数字签名技术—— 它在对单条消息签名时具备安全性，但如果用同一套密钥对多条消息签名，就会被攻击者破解并伪造签名。

应用场景：高安全、轻量化的场景比较适用。

> Lamport签名方案：得到一个巨长的签名。



#### 不可否认签名

由三部分组成：签名算法、验证协议、否认协议。

由Chaum 和van Antwerpen 在1989年提出，其中最主要的特征是没有签名者的合作，签名就不能得到验证。从而防止了由她签署的电子文档资料没有经过她的同意而被复制和分发的可能性。

如果要阻止她否认，一个不可否认签名与一个否认协议结合，通过这种方式A 能证明一个签名是伪造签名。



#### 群签名方案

群中各个成员以群的名义匿名地签发消息，由三个算法组成：签名算法、验证算法和识别算法。

1. 只有群内成员能为消息签名
2. 接收者能验证签名是来自于该群的合法签名
3. 接收者不能确认签名者是群内的哪一个人
4. 需要时可借助于群成员或者可信机构找到签名者

应用场景：公司打印机管理



#### 盲签名

应用场景：用户的支付信息（如金额、账户）盲化后交给银行签名，银行看不到具体支付详情，却能确认交易合法；用户还原签名后完成支付，第三方可验证签名来自银行，确保交易有效，但无法追溯用户隐私信息。

盲签名过程：消息→盲变换→签名→接收者→逆盲变换

> 怎么知道该不该对盲消息签名？---> 如果发送者篡改了原始消息 m，则盲消息会不符合数学规则，签名者可以拒绝签名；只有合法的盲化过程，才能让最终还原的签名有效。

---





# Lecture 7. 密码实际应用问题

## 一、Intro

#### 应用位置

从密码技术应用的逻辑位置看，数据链路层以下的加密称为链路加密，网络层以上的高层协议加密为端对端的加密。（加密载荷，不加密头）（在网关中要解密再重新加密）

<img src="./信息安全引论.assets/image-20251113162334359.png" alt="image-20251113162334359" style="zoom:50%;" />

#### 通信安全模型

<img src="./信息安全引论.assets/image-20251113162722131.png" alt="image-20251113162722131" style="zoom:40%;" />

#### 密钥管理

密钥都有生存周期（Cryptoperiods）：授权使用该密钥的周期。

> 因为 ①拥有大量的密文有助于密码分析；②在单一密钥受到威胁时，限制信息的暴露；③限制一技术使用到它估计的有效期；④限制计算密集型密码分析攻击的有效时间

密钥的生命流程：产生（可能需要登记）--> 分配 --> 使用 --> 更新/替换 --> 撤销 --> 销毁

建议密钥生存期：OUP（发起方使用期限：数据被加密的时间段），RUP（接收方使用期限：数据继续保持为密文直到解密的时间段）

<img src="./信息安全引论.assets/image-20251113171445129.png" alt="image-20251113171445129" style="zoom:50%;" />

密钥管理：在一种安全策略指导下密钥的产生、存储、分配、删除、归档及应用。维持系统中各实体之间的密钥关系，以抗击各种可能的威胁（eg. 密钥的泄露，秘密密钥或公开密钥的身份的真实性丧失，未经授权使用）



#### 密钥类型

1. 会话密钥（Session Key）：即两个通信终端用户在**一次通话**或交换数据时使用的密钥。当它用于加密文件时，称为文件密钥(File key)，当它用于加密数据时，称为数据加密密钥(Data Encrypting Key)。
2. 密钥加密密钥（Key Encrypting Key）：用于对会话密钥或文件密钥进行加密时采用的密钥。又称辅助（二级）密钥(Secondary Key)或密钥传送密钥(key Transport key)。
3. 主机主密钥（Host Master Key）：一般出厂的时候就存于主机处理器中。*一般用主机主密钥传递密钥加密密钥，用密钥加密密钥传递会话密钥*
4. 基本密钥（Base Key）：又称初始密钥（Primary Key)，用户密钥(User key)，是由用户选定或由系统分配给用户的，可在较长时间（相对于会话密钥）内由一对用户所专用的密钥。
5. 在公钥体制下，还有公开密钥、秘密密钥、签名密钥之分。



## 二、密钥管理

#### 密钥产生

- 两种方式：手工/自动化
- 选择密钥方式不当会影响安全性：使密钥空间减小（eg. 只使用小写字母）；差的选择方式易受[字典式攻击][利用预先构建的 “字典库”（包含大量可能的密钥字符串），逐一尝试匹配目标密钥]
- 好的密钥：真正的随机、等概
  - 避免使用特定算法的弱密钥
  - 公钥体制的密钥必须满足一定的数学关系
  - 选用易记难猜的密钥，如：一句话的首字母
- 不同等级的密钥的重要性不同，产生方式不同
  - 主机主密钥安全性至关重要，故要保证其完全随机性、不可重复性和不可预测性。可用投硬币、骰子，噪声发生器等方法产生。
  - 密钥加密密钥数量大(N(N-1)/2)，可采用一些安全算法或者伪随机数发生器由机器自动产生。
  - 会话密钥可利用密钥加密密钥及某种算法（加密算法、单向函数等）产生。
  - 初始密钥：类似于主密钥或密钥加密密钥的方法产生。

##### 集中式密钥与分散式密钥

- 集中式：在中心统一进行生产（eg. 传统的密钥分发中心KDC 和证书分发中心 CDC 等方案），生产有边界，边界以所能配置的密钥总量定义，其用户数量受限。密钥的认证协议简洁，交易中的安全责任由中心承担。

- 分散式：由个人生产，密钥生产无边界，其用户数量不受限制。密钥变量中的公钥必须公开，需经第三方认证，交易中安全责任由个人承担。

  

#### 密钥的登记

将产生的密钥与特定的使用捆绑在一起，例如，用于数字签名的密钥，必须与签名者的身份捆绑在一起。这个捆绑必须通过某一授权机构来完成。



#### 密钥的装入

- 主机主密钥: 直接或间接装入,装入时须有电磁屏蔽,装入后不能再读出(但可间接验证)
- 终端主密钥: 直接或间接装入,装入时须有电磁屏蔽,装入后不能再读出,可联机或者间接验证
- 会话密钥: 不存在装入问题



#### 密钥的存储和保护

密钥的完整性和机密性都需要保护。

> 最安全的方法是将其放在物理上安全的地方。当一个密钥无法用物理的办法进行安全保护时，密钥必须用其它的方法来保护：秘密共享；通过机密性（例如，用另一个密钥加密）和/或完整性服务来保护。

##### 公钥的存储

公钥也需要完整性真实性保护。

1. 将所有公钥存储在专用媒体（软盘、芯片等）一次性发放给各用户。
2. 用对方的公钥建立密钥环各自分散保存（如安全电子邮件系统PGP）。
3. 将各用户的公钥存放在公用媒体中。



#### 密钥分配

- 密钥分配协议：系统内的一个成员选择密钥，然后将它们安全传给其他成员。
- 密钥协定协议：系统两个或者多个成员在公开的信道上联合建立秘密密钥，两个成员的密钥协定也称为密钥交换。

详见[三-密钥分配](#三、密钥分配)



#### 密钥使用控制

确保打算用于一种目的的密钥不能和用于另一种目的的密钥交替使用。这就要求将密钥值和密钥的合法使用范围绑定在一起。也称为密钥隔离。

思想：把“用途”的消息摘要和密钥异或，只有任务一致才能解密。







## 三、密钥分配

### 密钥分配协议

#### 基于对称密码体制的密钥分配

金融机构密钥管理 ANSI X9.17（1985年）三层密钥层次结构：1. 主密钥（KKMs）通过手工分配；2. 密钥加密密钥（KKs），通过在线分配；3. 数据密钥（KDs）。

- 静态分配：是一种由中心以脱线方式预分配的技术。优点：安全性好，是长期沿用的传统密钥管理技术。缺点：必须解决密钥的存储技术。
- 动态分配：是“请求-分发”的在线分发技术。优点：分发及时，成本相对较低。缺点：需要有专门的协议的支持。

##### 主密钥的分配方式

利用安全信道实现：1. 直接面议或通过可靠信使递送 2.将密钥分拆成几部分分别传送

##### 密钥的静态配置

- 网状配置：两两用户之间都有密钥。

- 星状配置：<img src="./信息安全引论.assets/image-20251115194832010.png" alt="image-20251115194832010" style="zoom:33%;" />

  非对称密钥的话就由上级往下分发私钥、上级保管公钥。

##### 第三方

<img src="./信息安全引论.assets/image-20251113170006911.png" alt="image-20251113170006911" style="zoom:33%;" />

*optional应该指的是并非所有交互都必须经过TTP*

> eg. on-line：提供对称密钥；off-line：提供验证过的公钥。

##### 动态分配-KDC与KTC

为会话生成临时会话密钥。

KDC: 密钥分配中心（密钥由中心产生）*典型流程：A说我和B要用密钥，KDC生成密钥，用A和KDC的公共密钥加密后给A，用B和KDC的公共密钥加密后给B*

KTC: 密钥转递中心（密钥由用户产生）*典型流程：A说我有个密钥，KTC把密钥翻译成B能用的密钥然后发给B*

- 问题：B直接收到密钥就相信了，那其他人很容易伪造一个发给B啊。A随便发一个KDC就响应了，那其他人重发一个一样的KDC就继续加密了*（【重放攻击】eg. 拦截用户的 “转账 100 元” 加密请求后，多次重发该请求，可能导致用户重复转账）*

- Sol. 带鉴别与抗重放机制的密钥分配方案

  <img src="./信息安全引论.assets/image-20251120152500645.png" alt="image-20251120152500645" style="zoom:70%;" />

  N1，N2为随机数

  > 步骤 (1)：A 向 KDC 发起请求
  > 
  > - A 向 KDC 发送包含 随机数$$N_1$$ 的请求（Request || $$N_1$$）。
  > - 随机数$$N_1$$的作用：抗重放攻击（KDC 会验证该随机数的新鲜性，确保不是攻击者重放的旧请求）。
  > 
  > 步骤 (2)：KDC 生成并分发会话密钥
  > 
  > - KDC 生成会话密钥$$K_s$$，然后构造密文：$$E_{K_a}[K_s \parallel \text{Request} \parallel N_1 \parallel E_{K_b}(K_s, \text{ID}_A)]$$并发送给 A。
  > 
  > - $$E_{K_a}[\dots]$$：用 A 与 KDC 之间的 长期共享密钥$$K_a$$ 加密，确保只有 A 能解密。
  > - 密文内容包含：会话密钥$$K_s$$、A 的请求原文、随机数$$N_1$$（用于 A 验证 KDC 的响应新鲜性），以及用 B 与 KDC 的长期共享密钥$$K_b$$ 加密的$$(K_s, \text{ID}_A)$$（用于后续发给 B）。
  > 
  > 步骤 (3)：A 将 B 的密钥信息转发给 B
  > 
  > - A 从步骤 (2) 的密文中提取出$$E_{K_b}(K_s, \text{ID}_A)$$，并转发给 B。
  > 
  > - B 收到后，用自己与 KDC 的长期共享密钥$$K_b$$解密，即可获得会话密钥$$K_s$$和 A 的身份标识$$\text{ID}_A$$，从而确认 "这是 KDC 为 A 和自己分配的会话密钥"。
  > 
  > 步骤 (4)：B 向 A 发起身份认证
  > 
  > - B 生成随机数$$N_2$$，用会话密钥$$K_s$$加密后发给 A（$$E_{K_s}[N_2]$$）。
  > - 随机数$$N_2$$的作用：既用于 B 验证 A 的身份，也用于抗重放攻击（确保是新鲜的通信）。
  > 
  > 步骤 (5)：A 向 B 完成身份认证
  > 
  > - A 对$$N_2$$进行某种变换（如哈希函数$$f(\cdot)$$），再用会话密钥$$K_s$$加密后发给 B（$$E_{K_s}[f(N_2)]$$）。
  > - B 收到后，对自己生成的$$N_2$$执行相同变换，若结果一致，则确认 A 的身份合法（因为只有掌握$$K_s$$的 A 能正确变换$$N_2$$）。
  
  核心设计亮点：
  
  - 身份鉴别：通过 "随机数挑战 - 响应" 机制（$$N_2$$和$$f(N_2)$$），确保通信双方身份真实。
  - 抗重放攻击：利用随机数$$N_1$$（防止 A 重放对 KDC 的请求）和$$N_2$$（防止 B 或攻击者重放认证信息），保证每个通信流程都是 "新鲜" 的。
  
  缺点：KDC知道所有密钥，可以知道所有通信内容。

##### 动态分配-去中心化分配

<img src="./信息安全引论.assets/image-20251122144745116.png" alt="image-20251122144745116" style="zoom:50%;" />

> 
> 步骤 (1)：发起方 A 向响应方 B 发送请求，包含随机数$$N_1$$（用于抗重放攻击，确保请求的新鲜性）。
> 
> 步骤 (2)：B 生成会话密钥$$K_s$$，并构造密文：$$E_{\text{MKm}}[K_s \parallel \text{Request} \parallel \text{ID}_B \parallel f(N_1) \parallel N_2]$$
> 
> - $$\text{MKm}$$是 A 和 B 之间的长期共享主密钥（用于加密会话密钥等关键信息）
> - $$f(N_1)$$是对$$N_1$$的变换（验证 A 的身份）
> - $$N_2$$是 B 生成的新随机数（用于后续认证）
> 
> 步骤 (3)：A 用会话密钥$$K_s$$对$$N_2$$进行变换（如哈希函数$$f(N_2)$$），加密后发给 B，完成身份认证。
> 

核心设计亮点：

- 无中心化 KDC：通信双方通过长期共享主密钥直接协商会话密钥，避免了对第三方的依赖。
- 适用于小型网络（节点少、信任关系明确）





#### 基于公钥体制的密钥分配

##### Simple secret key distribution

啥也没干的基础公钥运作体系，中间人随意干预。

<img src="./信息安全引论.assets/image-20251120153847373.png" alt="image-20251120153847373" style="zoom:50%;" />

<img src="./信息安全引论.assets/image-20251120154008357.png" alt="image-20251120154008357" style="zoom:40%;" />

##### Simple secret key distribution with confidentiality and authentication

<img src="./信息安全引论.assets/image-20251122164309138.png" alt="image-20251122164309138" style="zoom:50%;" />

> 
> (1) A→B 发送 $$E_{\text{KUb}}[N_1 \parallel \text{ID}_A]$$ 用 B 的公钥 $$\text{KUb}$$ 加密，包含 A 的身份 $$\text{ID}_A$$ 和随机数 $$N_1$$，实现 A 的身份认证与抗重放攻击
> 
> (2) B→A 发送 $$E_{\text{KUa}}[N_1 \parallel N_2]$$ 用 A 的公钥 $$\text{KUa}$$ 加密，包含 A 的随机数 $$N_1$$（确认 B 已收到 A 的请求）和 B 的随机数 $$N_2$$（用于后续认证）
> 
> (3) A→B 发送 $$E_{\text{KUb}}[N_2]$$ 用 B 的公钥 $$\text{KUb}$$ 加密 B 的随机数 $$N_2$$，完成 B 对 A 的身份认证
> 
> (4) A→B 发送 $$E_{\text{KUb}}[E_{\text{KRa}}[K_s]]$$ 用 B 的公钥 $$\text{KUb}$$ 加密 "由 A 的私钥 $$\text{KRa}$$ 加密的会话密钥 $$K_s$$"，确保 $$K_s$$ 的保密性与完整性
> 
> (5) B 解密获取 $$K_s$$ B 先用自己的私钥 $$\text{KRb}$$ 解密外层，再用 A 的公钥 $$\text{KUa}$$ 解密内层，最终获得会话密钥 $$K_s$$

设计亮点：

- 保密性：会话密钥 $$K_s$$ 通过公钥加密双层保护，只有 B 能解密获取。
- 双向认证：通过随机数 $$N_1$$ 和 $$N_2$$ 的 "挑战 - 响应"，确保 A 和 B 身份真实，同时防止重放攻击。
- 无中心化依赖：通信双方仅通过彼此的公钥即可完成密钥分发与认证，适用于分布式网络环境。



#### Hybrid Scheme

公钥私钥都用。

- KDC与每个用户都拥有{公钥,私钥}对
- KDC与每个用户共享主密钥(对称密钥密码)
- 会话密钥的分发由主密钥完成
- 主密钥由公钥传递



### 密钥交换方案（密钥协定）

Diffie-Hellman 容易被中间人攻击 <img src="./信息安全引论.assets/image-20251120154605929.png" alt="image-20251120154605929" style="zoom:30%;" />

↓ 两个改进：STS，MTI

##### 端-端协议（STS协议）

station to station protocol

思想：用签名来验证是对的人。

证书：自己的ID信息 || 自己签名的验证算法 || 可信中心的签名(自己的ID信息 || 自己签名的验证算法)

- U正常发送 a^Xu^ mod p
- V回发：证书 || a^Xv^ mod p || 自己的签名(a^Xu^ || a^Xv^)
- U可以验证确实是V，再回发：证书 || 自己的签名(a^Xu^ || a^Xv^)
- V可以验证确实是U

##### MTI协议

MTI是三个人名）

- p、a：公开的 公共参数
- 每个用户有私钥X和公钥Y（Y= a^X mod p）
- 数字证书 C (U)：可信中心给 U 发的 “身份 + 公钥” 证明（包含 U 的 ID、Yu，还有可信中心的签名）。

步骤：

1. U 随机选个数字 Ru，算出来一个碎片 Su= a^Ru mod p，然后把 “自己的数字证书 C (U) + 碎片 Su” 发给 V；
2. V 也随机选个数字 Rv，算出来碎片 Sv= a^Rv mod p，然后把 “自己的数字证书 C (V) + 碎片 Sv” 发给 U；
3. 双方即可得到共享密钥K = Sv^Xu  ×  Yv^Ru  mod p。

> [!NOTE]
>
> MTI 只用 “数字证书” 确认 “公钥是真的”，但不验证 “交换的碎片有没有被改”—— 如果中间人截获了 U 的碎片，改成假碎片发给 V，V 没法察觉（因为 V 只知道公钥是真的，但不知道碎片是真的）。
>
> 而 STS 的签名，既解决了 “身份冒充”，又解决了 “信息篡改”，安全性比 MTI 更高。



## 四、其他

#### 密码长度

<img src="./信息安全引论.assets/image-20251122170306146.png" alt="image-20251122170306146" style="zoom:50%;" />

<img src="./信息安全引论.assets/image-20251122170424954.png" alt="image-20251122170424954" style="zoom:40%;" />

<img src="./信息安全引论.assets/image-20251122170519921.png" alt="image-20251122170519921" style="zoom:50%;" />

*“MIPS 年” 是密码学中用于衡量大整数分解等密码学运算所需计算量的单位，具体含义是：以每秒执行 100 万条指令（MIPS，Million Instructions Per Second）的计算机为基准，完成某一运算所需的 “年数”。*

<img src="./信息安全引论.assets/image-20251122170700402.png" alt="image-20251122170700402" style="zoom:40%;" />



#### 软硬件加密

软件加密：

- 缺点：速度慢、造价高、安全性差
- 优点：使用灵活、修改方便、可移植性好

硬件加解密是商业或军事上的主流。

##### 侧信道攻击

一种由于密码系统的**物理特性**造成的信息泄漏引发的攻击。攻击者利用物理环境恢复一些可用于破坏密码算法的泄漏，在侧信道攻击中可以利用的特性包括运行时间、功耗、电磁和声发射。

对策的示例：包括向计算添加随机延迟、插入没有任何影响的指令周期，使得每次密码计算都需要相同的时间，以及添加导致随机功耗的硬件逻辑。



#### 轻量级密码学

轻量级密码学是密码学的一个子领域，涉及资源受限设备的密码算法的开发



#### 压缩、编码和加密

- 将压缩算法和加密算法结合使用效果更好。
  （1）密码分析依赖于明文中的数据冗余，而压缩明文会减少这种冗余。
  （2）减少加密时间
- 顺序：<img src="./信息安全引论.assets/image-20251122170826602.png" alt="image-20251122170826602" style="zoom:50%;" />



#### 文件删除

大多数计算机删除文件时，只是删除文件的索引，此外，虚拟存储器意味着计算机可以在任何时候往硬盘上读、写数据。建议多次往硬盘上重写，才能保证删除干净。

---





# Lecture 8. 公开密钥管理

## 一、Intro

**PKI：public key infrastructure** 是一组建立在公开密钥算法基础上的硬件、软件、人员和应用程序的集合，它应具备产生、管理、存储、分发和废止证书的能力。

##### 组成

- CA(Certificate Authority)：是证书的签发机构，它是PKI 的核心。
- 注册中心RA：分担CA 的功能，作为CA 和最终用户之间的接口，增强CA 系统的安全性。
- 证书库：是一种网上公共信息库，用于存储CA已签发证书及公钥、撤销证书及公钥，可供开放式查询。
  - CRL（证书吊销列表，Certificate Revocation List）是由证书颁发机构（CA）发布的一个列表，它列出了所有被吊销的数字证书。这些证书已经不再有效，不能再用于身份验证或者加密通信。

- 密钥和证书管理：涉及密钥备份与恢复、自动密钥更新和建立密钥历史档案。
- 一个完整的PKI 还必须提供良好的应用接口系统。
- 信任模型：涉及不同PKI管理的用户之间交叉认证。

##### 证书

一个证书中，最重要的信息是个体名字、个体的公钥、机构的签名、算法和用途。

X.509证书结构： <img src="./信息安全引论.assets/image-20251122173350750.png" alt="image-20251122173350750" style="zoom:40%;" />





## 二、PKI 信任模型

#### 概念

- 如果一个个体假设CA 能够建立并维持一个准确的“个体公钥属性”之间的绑定，则他可以信任该CA，该CA 为可信CA

- 信任域：信任的范围。

- 信任锚：就是PKI 体系中的信任起点。

- 在公钥基础设施中，当两个认证机构中的一方给对方的公开密钥或双方给互相的公开密钥颁发证书时，两者之间就建立了信任关系。

- 在一个实体需要确认另一个实体身份时，它先需要确定信任锚，再由信任锚找出一条到达待确认实体的各个证书组成的路径，该路径称为信任路径。

  

#### 一些结构

1. 严格层次结构模型

   <img src="./信息安全引论.assets/image-20251122173550217.png" alt="image-20251122173550217" style="zoom:30%;" />

   - 根CA 具有一个自签名的证书。
   - 用户A看是否信任用户B时，可以看到B的证书中含有签发该证书的CA 的信息，沿着层次树往上找，就可以构成一条证书链，直到根证书。只要信任根CA就可以。因为可以用根CA的公钥验证其子CA证书...依次往下都可验证。

2. 网状信任模型

   <img src="./信息安全引论.assets/image-20251122210401239.png" alt="image-20251122210401239" style="zoom:35%;" />

3. 桥CA信任模型

   <img src="./信息安全引论.assets/image-20251122210452225.png" alt="image-20251122210452225" style="zoom:40%;" />

4. Web模型：网站内置数个可信任的根CA

   <img src="./信息安全引论.assets/image-20251122210702643.png" alt="image-20251122210702643" style="zoom:33%;" />

----





# Lecture 9. 加密文件系统

Windows 自带了**加密文件系统 EFS（Encrypting File System）**加密文件系统。

- 该技术允许用户加密[NTFS卷][NTFS卷是指采用NTFS（New Technology File System，新技术文件系统）作为文件管理格式的逻辑存储分区。一个物理磁盘可以划分多个 NTFS 卷（如 C 盘、D 盘）]上特定文件夹中的数据
- 加密一个文件只需设置文件的加密属性或把文件放入设置了加密属性的文件夹之中。
- 系统文件不能被加密
- 加密不能防止被删除

#### 原理

基于非对称公钥算法和对称加密算法的混合机制：扩展的数据加密标准（DESX)

本质是用 [对称加密密钥] 加密文件。为了保护 [对称加密密钥] 的安全，所以用 [公钥] 加密 [对称加密密钥]。解密时用 [私钥] 解密 [对称加密密钥]，再用 [对称加密密钥] 解密即可。

*使用公私钥是因为如果直接保存对称加密密钥在电脑上的话会很容易被攻击者获得，因此保存加密的版本，私钥存储在一个安全储存区。*

*备份文件加密证书和密钥有助于避免在丢失或损坏原始证书和密钥之后永久丢失对加密文件的访问权限*



#### 一个实际操作例子

见PPT。加密文件夹、导出公私钥（备份）、导入...

##### 配置数据恢复代理

由于EFS 的加密和解密与用户的账户信息和个人配置文件密切相连，如果用户忘记了自己的登录口令或是登录口令被系统管理员更改、个人配置文件损坏或丢失，都会造成文件永远处于加密状态不允许任何人进行访问，由于EFS 的加密强度极高，因此恢复的可能性很小。为了预防这些情况的发生，用户在启用EFS 后，要配置数据恢复代理为自己留一条后路。

**数据恢复代理**：一个其他用户。

由于受到系统加密策略的控制，配置了数据恢复代理后再对文件进行加密，在文件中会自动产生一个与数据恢复代理用户相关联的数据恢复字段，这个字段保存了由数据恢复代理的公钥进行加密的文件加密密钥，当数据恢复代理访问这些加密文件时，用自己的私钥解密从而得到加密密钥。

---





# Lecture 10. 网络安全

## 一、Intro

- 应用层安全：必须在终端主机上实施，每两个用户都要有密钥
  - 优点：以用户为背景执行；数据只有到用户的主机上才恢复成明文；应用可以自由扩展；应用程序对数据有着充分的理解
  - 缺点：针对每个应用须设计一套安全机制
- 传输层安全：
  - 优点：不会强制要求每个应用都在安全方面作出相应改进
  - 缺点：由于要取得用户背景，通常假定只有一名用户使用系统，与应用级安全类似，只能在端系统实现；应用程序仍需要修改
- 网络层安全：节点之间共享密钥即可
  - 优点：密钥协商的开销被大大削减了；需要改动的应用程序要少得多；能很容易构建VPN
  - 缺点：很难解决“抗抵赖”之类的问题（因为和用户无关了）
- 数据链路层：
  - 优点：速度快，在ATM 上得到广泛应用
  - 缺点：不易扩展

> [!NOTE]
>
> 网络层 IPsec
> 传输层 SSL / TLS
> 应用层 S/MIME, PGP, PEM, SET, Kerberos, SHTTP, SSH



## 二、传输层安全

### SSL/TLS协议

> [!NOTE]
>
> 浏览器地址栏旁边显示一个小锁即为被SSL/TLS协议保护着！

SSL/TLS 被设计用来使用 TCP 提供一个可靠的端到端安全服务。为两个通讯个体之间提供保密性和完整性（身份鉴别）。

SSL (Secure Socket Layer) 发展三代后重命名为 TLS (Transport Layer Security)

<img src="./信息安全引论.assets/image-20251127161453300.png" alt="image-20251127161453300" style="zoom:50%;" />

- TLS 记录协议：发送数据时使用的协议，对数据进行封装（加密、校验等）。
  - *生成TLS连接（一次交互就叫一次连接）*

- TLS 握手协议：客户和服务器之间相互鉴别，协商加密算法、哈希算法、密钥以及其他参数。`主密钥：双方长期共享的密钥`
  - *生成TLS会话（从握手到挥手称为一次会话，会存储密码安全参数）*




#### TLS 记录协议

<img src="./信息安全引论.assets/image-20260106132214665.png" alt="image-20260106132214665" style="zoom:40%;" />

- 上层消息的数据被分片成2^14^字节大小的块，或者更小，适合加密。
- TLS记录头：
  - 内容类型：上层协议类型
  - 协议主从版本号：
  - 明文长度



#### TLS 握手协议

<img src="./信息安全引论.assets/image-20260106133353688.png" alt="image-20260106133353688" style="zoom:50%;" />

> 密钥的产生：
>
> 为了产生记录协议所需要的密钥，使用下面的计算公式：
>
> key_block = [PRF][一个伪随机函数](SecurityParameters.master_secret，“key expansion expansion”, SecurityParameters.server_random+SecurityParameters.client_random)；
>
> 直到产生足够长的输出。然后从key_block 中按以下顺序依次取得相应长度的密钥：客户端写MAC 密钥、服务器端写MAC 密钥、客户端加密密钥、 服务器端端加密密钥、客户端写IV 、服务器端写IV 。

> [!NOTE]
>
> 一款开源软件：OpenSSL，支持生成私钥、生成证书签名请求、使用私钥签名证书请求、生成对称密钥、加密文件、解密文件





## 三、网络层安全

> IPv4的缺陷：
>
> - 缺乏对通信双方身份真实性的鉴别能力
> - 缺乏对传输数据的完整性和机密性保护的机制
> - IP的分组和重组机制不完善
> - IP地址的表示不需要真实并确认真假

### IPsec

IPsec定义了两个协议 AH (Authentication Header) 和 ESP (Encapsulating Security Payload)，分别用于鉴别与加密。都以扩展报头的形式存在。

应用方式：

- 端到端（end-end）：主机到主机的安全通信
- 端到路由（end-router）：主机到路由设备之间的安全通信
- 路由到路由（router-router）：路由设备之间的安全通信，常用于在两个网络之间建立VPN。



#### 安全关联 Security Association

安全关联定义：就是发送与接收者之间的一个**单向**逻辑连接，是与给定的一个网络连接或一组网络连接相关联的安全信息参数集合。*如果需要一个对等关系，即双向安全交换，则需要两个SA。*

每个SA通过三个参数来标识：

1. 安全参数索引 SPI (Security Parameters Index) *因为一个设备会建立多个连接，所以可以通过此索引快速找到这个链接使用的那组安全参数*
2. 对方IP地址
3. 安全协议标识: AH or ESP

- 安全关联数据库 SAD：存储了当前活跃的连接的安全参数们
- 安全策略数据库 SPD：在每个条目中定义了要保护什么样的通信、怎样保护它以及和谁共享这种保护

> eg. 可在一个安全网关上制定IPSec策略: 对在本地保护的子网与远程网关的子网间通信的所有数据，全部采用DES加密，并用 HMAC-MD5进行鉴别；对于需要加密的、发给另一个服务器的所有 Web通信均用 3DES加密，同时用 HMAC-SHA鉴别。



#### AH 与 ESP

AH利用MAC码实现鉴别，双方必须共享一个密钥

两种鉴别模式：

1. 传输模式：不改变 IP地址，插入一个 AH

2. 隧道模式：生成一个新的 IP头，把 AH和原来的整个 IP包放到新 IP包的净荷数据中

   <img src="./信息安全引论.assets/image-20260106143522949.png" alt="image-20260106143522949" style="zoom:33%;" />

   ESP类似，只是提供加密和可选的鉴别服务。*注意ESP的鉴别不包括头部，AH的鉴别包括头部*

   <img src="./信息安全引论.assets/image-20260106144210079.png" alt="image-20260106144210079" style="zoom:33%;" />

   <img src="./信息安全引论.assets/image-20260106144228599.png" alt="image-20260106144228599" style="zoom:33%;" />

##### SA的组合

特定的通信量需要同时调用 AH和 ESP服务。

- 传输邻接：同一分组应用多种协议，不形成隧道

  即：AH + 一个不提供鉴别服务的ESP，这样可以比单使用ESP多保护一个头部。

  <img src="./信息安全引论.assets/image-20260106145255302.png" alt="image-20260106145255302" style="zoom:40%;" />

- 循环嵌套：通过隧道实现多级安全协议的应用（多重隧道）

  即：内部的AH + 外部的 ESP 隧道

  <img src="./信息安全引论.assets/image-20260106145451961.png" alt="image-20260106145451961" style="zoom:40%;" />

  先鉴别再加密，更不易被篡改，且解密后仍然可以保留完整性保护。



#### IPsec密钥管理

**IKE协议**：代表 IPsec对 SA进行协商，并对 SAD数据库进行填充，基于 Diffie-Hellman 算法。

---





# Lecture 11. 鉴别协议

## 一、一些协议

#### 仲裁协议/裁决协议

包括两个低级的子协议

- 非仲裁子协议，执行协议的各方每次想要完成的（谈合同、签合同）
- 裁决子协议，仅在例外的情况下，即有争议的时候才执行（见法官，出示证据），这种特殊的仲裁者叫裁决人。

#### 密码协议/安全协议

使用密码的具有安全性功能的协议称为安全协议或密码协议

1. 密钥建立协议(key establishment protocol): 建立共享秘密
2. 鉴别协议(authentication protocol): 向一个实体提供对他想要进行通信的另一个实体的身份的某种程度的确认
3. 鉴别的密钥建立协议(authenticated key establishment protocol): 与另一个身份已被或可被证实的实体之间建立共享秘密



## 二、鉴别协议

### 实体鉴别概述

需求：验证一个实体是否是他声称的身份。

- 实体鉴别只证实实体的身份，消息鉴别除了验证消息来自真正的发送方，还要保证消息的合法和完整
- 实体鉴别一般是实时的鉴别，数字签名是长期有效的。

#### 实体鉴别分类

- 本地多用户鉴别：实体在本地环境的初始化鉴别（就是说，作为实体个人，和设备物理接触，不和网络中的其他设备通信）。需要用户进行明确的操作
- 远程用户鉴别：连接远程设备、实体和环境的实体鉴别。通常将本地鉴别结果传送到远程。

- 单向鉴别是指通信双方中只有一方向另一方进行鉴别。
- 双向鉴别是指通信双方相互进行鉴别。



### 实体鉴别机制

大致分类：

1. 所知(Knowledge):密码、口令

2. 所有(Possesses): 身份证、护照、信用卡、钥匙、IP地址、设备

3. 个人特征:指纹、笔迹、声纹、手型、血型、视网膜、虹膜、DNA以及个人动作方面的一些特征

   

#### 口令机制

即日常生活中所说的“密码”。通常为长度为5~8 的字符串。选择原则：易记、难猜、抗分析能力强。

是**弱鉴别**：口令不随时间变化。

口令系统有许多脆弱点：外部泄露、口令猜测、线路窃听（可以传输/存储口令的消息摘要）、攻击验证者、重放

> [!NOTE]
>
> 防止攻击验证者：
>
> - 验证者的存储准备：验证者本地不会存储用户的明文口令，而是存储：
>   - 用户身份标识（`id`）；
>   - 一个随机的 “盐值（salt）”（每个用户的盐值不同）；
>   - 用 单向函数`f` 计算出的 “口令 + 盐值” 的哈希结果：`q = f(p, salt)`（`p`是用户真实口令）。
> - 身份验证流程：
>   1. 用户（声称者）向验证者发送自己的`id`和输入的口令`p'`；
>   2. 验证者根据`id`，取出对应的`salt`和预先存储的`q`；
>   3. 验证者用单向函数`f`，计算用户输入的`p'`+`salt`的结果：`q' = f(p', salt)`；
>   4. 验证者对比`q'`和预先存储的`q`：一致则验证通过，不一致则失败。

> 防止线路窃听：
>
> 1. 验证者发起挑战
>    - 验证者先给声称者发送 “身份标识（id）” + “随机挑战值（q）”；
> 2. 声称者生成响应
>    - 声称者拿到`q`后，用自己的口令（`p'`）和单向函数（`f`），计算出响应值：`q' = f(p', q)`；
>    - 单向函数`f`的特点是 “易算难逆”—— 知道`p'`和`q`能算出`q'`，但知道`q'`和`q`无法反推出`p'`；
>    - 声称者将`id`和`q'`发送给验证者。
> 3. 验证者比对结果
>    - 验证者本地存储了该用户的真实口令（`p`），用同样的单向函数计算：`q = f(p, q')`对应的正确值；
>    - 验证者将自己计算的结果，与之前发送的q对比：
>    - 若一致，说明声称者确实知道正确口令，验证通过；
>    - 若不一致，验证失败。




##### 一次性口令机制

是**近似的强鉴别**（towards strong authentication)：一次性口令机制确保在每次鉴别中所使用的口令不同，以对付重放攻击。

确定口令的方法：

1. 两端秘密共享一串随机口令，在该串的某一位置保持同步，此方案有两端需要维护秘密随机串表的缺点；
2. 顺序更新一次性口令，使用旧的口令把新的口令加密传输过去。



#### 基于密码算法的鉴别

是**强鉴别**：通过密码学的询问应答(challenge response) 协议实现的身份鉴别 *不知道密码的人就算不出这个应答*



#### 零知识证明协议

>Alice: 我知道联邦储备系统计算的口令
>Bob: 不，你不知道
>Alice：我知道
>Bob：你不知道
>Alice：我确实知道
>Bob：请你的证实这一点
>Alice：好吧，我告诉你。（她悄悄说出了口令）
>Bob：太有趣了！现在我也知道了。我要告诉《华盛顿邮报》
>Alice：啊呀！:(



### 鉴别与密钥交换协议

先鉴别身份没问题，再交换密钥。

##### 询问/应答方式

1. A期望从B获得一个消息，首先发给B一个**随机值**(challenge)
2. B收到这个值之后，对它作某种变换，并送回去
3. A收到B的response，希望包含这个随机值。

在有的协议中，这个challenge也称为**nonce**，可能明文传输，也可能密文传输

询问/应答方法不适应非连接性的应用，因为它要求在传输开始之前先有握手的额外开销，这就抵消了无连接通信的主要特点。

##### 相互鉴别协议

在理论上，相互鉴别可通过组合两个单向鉴别交换协议来实现。然而，这种组合需要被仔细地考察，因为有可能这样的组合易受窃听重放攻击。

另外，设计协议消息数比相应的单向交换协议的消息数的两倍少得多的相互鉴别交换协议是可能的。

因此，由于安全性和性能的原因，相互鉴别交换协议必须为此目的而特别地进行设计。





## 三、鉴别与密钥交换协议实例

### CHAP

<img src="./信息安全引论.assets/image-20260107100334661.png" alt="image-20260107100334661" style="zoom:40%;" />

- 优点：简单易实现

- 缺点：基于共享密钥，给密钥管理带来巨大不便，不适合于大规模用户鉴别；要求提供明文的密钥形式。

  

### S/Key

主要用于抗重放攻击。主要功能：产生一次性口令。

机制：

1. 一个单向函数f（哈希摘要）
2. 产生一个随机数x，生成f(x), f(f(x)), ... 共一百个
3. 对面先存第101个，自己从第100个开始发，则对面可以轻松验证，并存下第100个，准备验证第99个。

实际过程中，由用户输入私钥，客户端程序计算出第k个口令。

整个过程中，私钥不会暴露在网上。



### 双向鉴别

#### Needham/Schroeder Protocol [1978]

<img src="./信息安全引论.assets/image-20260107102213363.png" alt="image-20260107102213363" style="zoom:50%;" />

- 漏洞：第三步可能遭遇抗重放攻击。eg. 攻击者得知了某次老的会话密钥，重放当时A发给B的(3)，就可以与B通话了。

#### Denning Protocol

为了解决这个漏洞，所以在第三步加一个时间标记。

- 新的问题：即必须依靠各时钟均可通过网络同步。如果发送者的时钟比接收者的时钟要快，攻击者就可以从发送者窃听消息，并在以后当时间戳对接收者来说成为当前时重放给接收者。这种重放将会得到意想不到的后果。（称为抑制重放攻击）。
- 一种克服抑制重放攻击的方法是强制各方定期检查自己的时钟是否与KDC 的时钟同步。

#### KEHN92

再带上双方的随机数。

<img src="./信息安全引论.assets/image-20260107103117948.png" alt="image-20260107103117948" style="zoom:40%;" />



### 单向鉴别

<img src="./信息安全引论.assets/image-20260107103727460.png" alt="image-20260107103727460" style="zoom:33%;" />



### Kerberos

希腊神话故事中一种三个头的狗，还有一个蛇形尾巴。是地狱之门的守卫。

意指有三个组成部分的网络之门的保卫者。“三头”包括：

- 鉴别(authentication)
- 簿记(accounting)
- 审计(audit)

应用场景：禁止非授权用户访问服务器，或者用户访问非授权服务器

引入一个信任的第三方鉴别服务，基于Needham & Schroeder 协议。



#### 一些协议中的概念

- Principal (安全个体)：被鉴别的个体，有一个名字和口令
- KDC(Key distribution center)：可信第三方提供 ticket 和临时的会话密钥
- Ticket：可信第三方给用户发的入场券，加密（使用可信第三方和服务器的共有密钥）
- Authenticator：证明我是我自己。



#### 改进

希望可以少输入几次口令，同一个入场券多次使用。TGS：ticket granting servor

1. Customer和AS沟通，AS给一份TGS访问许可，在有效期内可以重复使用。*用AS和TGS的共享密钥加密。*
2. C去找TGS要server的入场券。*用TGS和server的共享密钥加密。*
3. C给server看入场券。

缺点：server没有向用户证明自己。



#### Kerberos v4

增加会话密钥，使得用户知道server是真的server。*即在第三步时，需要server回复一个以K~cs~[timestamp+1]*

每个TGS有一定的管辖范围，可以访问隔壁的TGS以连接realm B的服务器。

<img src="./信息安全引论.assets/image-20251211154855290.png" alt="image-20251211154855290" style="zoom:30%;" />



#### Kerberos v5

1. 时间戳改为nonce
2. 加密算法换成了更严谨的
3. ticket本身就是一个密文，所以不用再用户二次加密了，省下一些计算量。
4. 有了子会话密钥



### X.509 

基于公钥。不需要服务器时刻在线。

三向交换可以用随机数代替时间戳。

<img src="./信息安全引论.assets/image-20260107112502155.png" alt="image-20260107112502155" style="zoom:40%;" />

---





# Lecture 12. 访问控制

## 零、概念

目标：防止对任何资源（如计算资源、通信资源或信息资源）进行未授权的访问。

访问控制[策略][策略：高层思想指导, eg. 入校要不要验证。机制：低层具体实现，eg. 采用人脸认证/校园卡认证。]：自主访问控制、强制访问控制、基于角色的访问控制、其他访问控制策略



## 一、自主访问控制 DAC

DAC：Discretionary Access Control

文件的拥有者可以按照自己的意愿精确指定系统中的其他用户对其文件的访问权（具有某种访问能力的主体能够自主地将访问权的某个子集授予其它主体）

也称为 **基于身份的访问控制** Identity Based Access Control

> [!NOTE]
>
> 密码非常适合用户鉴别，是否使用密码就可以实现自主访问控制？
>
> 不是非常合适，无法单独吊销一个用户的访问权；用户得自己记密码；系统无法获知访问文件的用户是谁。



### 实现机制

#### 访问控制矩阵

<img src="./信息安全引论.assets/image-20251211163854838.png" alt="image-20251211163854838" style="zoom:50%;" />

可以按行看或按列看。

##### 基于行

- 访问能力表 Capability List CL：效率不高

  <img src="./信息安全引论.assets/image-20251211164011772.png" alt="image-20251211164011772" style="zoom:33%;" />

- 前缀表：效率不高

  <img src="./信息安全引论.assets/image-20251217184456460.png" alt="image-20251217184456460" style="zoom:50%;" />

- 口令：即密码，前面有说。

##### 基于列

**访问控制表ACL**：每个客体附加一个它可以访问的主体的明细表，只要使用组（如CRYPTO）和通配符（如* ），表也可以不是太大。*多数集中式操作系统使用ACL，由于分布式系统中很难确定给定客体的潜在主体集，在现代OS 中CL 也得到广泛应用。*

<img src="./信息安全引论.assets/image-20251217184717334.png" alt="image-20251217184717334" style="zoom:60%;" />

如图，则CRYPTO小组中Jones可以rwx，其余人可以r_x，非CRYPTO小组中Green无权限，其他人可以read。



#### Linux中的访问控制

`权限分为：读、写、执行`

采用DAC。

访问权限(access rights): 10 个标志

- 第1 个标志：d (目录), b (块系统设备), c (字符设备), . (普通文件)
- 第2-4 个标志：**所有者**的读、写、执行权限
- 第5-7 个标志：**所有者所在组**的读、写、执行权限
- 第8-10 个标志：**其他用户**的读、写、执行权限

**根用户**拥有任何权限。

用chmod 修改权限。



#### Windows中的访问控制

采用DAC。采用ACL。

- 账户 user accounts 中包含安全id **SID**: 一个时间和空间唯一，全局惟一的48位数字。

  eg. S-1-5-21-1507001333-120455076-1011284298-500

- 所有对对象的访问都要通过安全子系统的检查

- 系统中的所有对象都被保护起来

  - 文件、目录、注册表键、内核对象、同步对象、私有对象 如打印机等、管道、内存、通讯，等

- 对象的安全描述符 security descriptor **SD**: 包含了与一个安全对象有关的安全信息

  - Security identifiers (SIDs) for the owner and primary group of an object
  - DACL(discretionary access control list)
  - SACL(system access control list)
  - 以及一组控制标记

- Security Access Token 是站在主体这方对权限的描述，是一个基本的安全单元，每个进程一个。

  - 用户帐户的SID
  - 所有包含该用户的安全组的SIDs
  - 特权：该用户和用户组所拥有的权利
  - Owner
  - Default Discretionary Access Control List

Win10中权限类型包括：完全控制、拒绝访问、修改、读取和执行、列出文件夹内容、读取、写入、特殊权限



### 授权管理方式

- 集中式管理：只有单个的管理者或组对用户进行访问控制授权和授权撤消。
- 分级式管理：一个中心管理者把管理责任分配给其它管理员，这些管理员再对用户进行访问授权和授权撤消。分级式管理可以根据组织结构而实行。
- 所属权管理：对每个客体设置一个拥有者 通常是客体的生成者 。拥有者是唯一有权修改客体访问控制表的主体，拥有者对其客体具有全部控制权
- 协作式管理：对于特定系统资源的访问不能有单个用户授权决定，而必须要其它用户的协作授权决定。
- 分散式管理：在分散管理中，客体所有者可以把管理权限授权给其他用户





## 二、强制访问控制 MAC

MAC：mandatory access policy

> 木马：一段进行非法操作的程序，其行为方式不会引起用户的怀疑。必须设计出某种策略诱使受骗者接受这段程序，必须使受骗者运行该程序，且入侵者必须有某种手段回收由木马发作为他带来的利益。

在DAC 控制下，以某个用户身份运行的程序可以任意地修改该用户所拥有文件的访问控制信息，而操作系统无法区分修改信息的是一个合法用户还是一个木马。

- 尽管系统可以对拥有特权的特定程序修改访问控制信息的能力进行限制，但同时会失去灵活性。
- 实际上，在DAC 控制下并没有办法防止木马通过共享客体（比如文件、消息和共享内存等），把消息从一个进程传给另一个进程。

### 强制访问控制的概念

- 为每个主体(subjects)和客体(objects)赋予**安全属性**(security attributes)，这些属性**不可以随意改变**。
- 系统通过比较主体和客体的安全属性来决定该主体能否以期望的方式访问该客体。
- 反之，如果系统判定拥有某一安全属性的主体不能访问某个客体，那么任何人(包括客体的拥有者)也不能使它访问该客体。*所以称为“强制”*
- 可以阻止进程创建共享文件，避免利用这些共享文件将敏感信息传递给另一个进程。

**多级安全**：将文件按不同的密级 classification 进行分类，将用户按许可级 clearance 分类。要想合法地获得信息，用户所具有的许可级别必须大于或等于信息的密级。

- 多级安全系统的主要目标是实施强制机密性安全策略

> 安全集之间的支配关系
>
> A 支配 B：即A 的密级不小于B 的密级，A 的范畴集包含B 的范畴集。
>
> A 等于 B：即A 的密级等于B 的密级，A 的范畴集等于B 的范畴集。
>
> A 、B 无关：即A 的范畴集不包含B 的范畴集，B 的范畴集也不包含A 的范畴集



### Bell-LaPadula 模型

简单安全模型：**无上读**（文件安全级别大于主体的话，主体就不能阅读）

**无下写**：级别高的程序不能往低密级文件写，因为存在信息泄露的风险。

密级：绝密 Top Secret > 机密 Confidential > 秘密 Secret > 无密级 Unclassified



### Biba 模型

完整性保护：**无上写**（低级别主体不能篡改高级别信息），可上读（读上级指令），**无下读**



### MAC规则实施

主体的安全级 = 以用户身份运行的进程的安全级

- 若进程以“r”( 或“x”) 方式访问客体，进程的安全级须支配客体的安全级；
- 若进程以“w” 方式访问客体，进程的安全级须等于客体的安全级。



如何防止木马

- Example1: 在多级安全系统中，正在机密安全级上运行的进程中的特洛伊木马不能把机密信息写入一个公开的文件里。**无下写**
- Example2: 一个公司对系统中自己拥有的信息指定一个强制存取范畴ｃ，只有该公司的雇员才可能进入这个范畴ｃ。如果它的一个雇员使用了特洛伊木马，他不可能将该公司的信息传递到ｃ范畴以外的地方去，但在范畴ｃ内部，信息可以在各个用户之间自由传递。

在强制访问控制中，允许的访问控制完全是根据主体和客体的安全级别决定。其中主体（用户、进程）的安全级别是由系统安全管理员赋予的，而客体的安全级别则由系统根据创建它们的用户的安全级别决定。因此，强制访问控制的管理策略是比较简单的，只有安全管理员能够改变主体和客体的安全级别。



### TCSEC 评估等级

<img src="./信息安全引论.assets/image-20260107114810702.png" alt="image-20260107114810702" style="zoom:50%;" />





## 三、基于角色的访问控制

定义角色权限，给用户分配角色。

RBAC：role-based access policy

### RBAC的安全原则
- 最小权限：只把必须的权限分配给角色
- 责任分离(separation of duties): 多个互斥的角色合作完成重要工作
- 数据抽象：可以定义抽象的权限，而不仅仅是OS 中的读、写、执行等

#### 基本RBAC

五个基本数据元素：用户users(USERS) 、角色roles（ROLES）、目标objects（OBS）、操作operations(OPS) 、许可权permissions(PRMS)

用户通过一个会话激活一个角色，角色拥有相应的操作权限。



#### 等级RABC

*上级可以继承下级的权限。*通过角色的结构化分层来定义权限的继承关系。



#### 有约束的RABC

- 静态责任分离：一个人只能是一个角色 *不能同时当银行职员和存钱的人*
- 动态责任分离：在不同的时间（不同的会话）可以拥有不同的角色



#### 优势

> - 便于授权管理，如系统管理员需要修改系统设置等内容时，必须有几个不同角色的用户到场方能操作，从而保证了安全性。
> - 便于根据工作需要分级，如企业财务部门与非财力部门的员工对企业财务的访问权就可由财务人员这个角色来区分。
> - 便于赋于最小特权，如即使用户被赋于高级身份时也未必一定要使用，以便减少损失。只有必要时方能拥有特权.
> - 便于任务分担，不同的角色完成不同的任务。
> - 便于文件分级管理，文件本身也可分为不同的角色，如信件、账单等，由不同角色的用户拥有。



> [!NOTE]
>
> DAC、MAC、RBAC 可以叠加使用。





## 四、其他

### 基于任务的访问控制 TBAC

根据任务分配权限。任务终止权限就收回。

### 基于属性的访问控制 ABAC

可以根据各种各样的属性来赋予权限，比如

- 主体属性：身份、角色、职位、年龄
- 资源属性：资源的身份、位置、大小
- 环境属性：如时间、系统状态

> [!NOTE]
>
> 依赖于值的控制：目标数据项无论数据值存储在哪儿，都有确定的访问控制许可。目标的敏感性会根据当前存储的数据值而改变。*工资高于xx的人不显示*
> 基于上下文的控制：允许访问控制策略在确定访问一个目标时依靠外部因素（时间、位置、通信路径、鉴别强度）。

### 基于规则的访问控制 rule-BAC

针对请求本身进行访问控制。

一个典型的例子就是防火墙。防火墙通过将请求的源 IP 和端口、目标 IP 和端口、协议等特征获取到后，根据定义好的规则，来判定是否允许主体访问。

---





# Lecture 13. 网络攻防技术

> 黑客种类：
>
> - 飞客“phreak”：早期攻击电话网的青少年，研究各种盗打电话而不用付费的技术。
> - 黑客“Hacker”：一个给予喜欢发现和解决技术挑战、攻击计算机网络系统的精通计算机技能的人的称号，与闯入计算机网络系统目的在于破坏和偷窃信息的骇客不同。
> - 骇客“Cracker”：一个闯入计算机系统和网络试图破坏和偷窃个人信息的个体，与没有兴趣做破坏只是对技术上的挑战感兴趣的黑客相对应。
> - 快客“Whacker”：从事黑客活动但没有黑客技能的人，whacker是穿透系统的人中，在技术和能力上最不复杂的一类。
> - 武士“Samurai”：被他人雇佣的帮助他人提高网络安全的黑客，武士通常被公司付给薪金来攻击网络。
> - 幼虫“Larva”：一个崇拜真正黑客的初级黑客
> - 欲望蜜蜂“Wannabee”：处于幼虫的初始阶段的黑客的称呼，他们急于掌握入侵技术，但由于他们没有经验，因此即使没有恶意也可能造成很大危险
> - 黑边黑客（Dark-Side）：是指由于种种原因放弃黑客的道德信念而恶意攻击的黑客
> - 半仙“Demigod”：一个具有多年经验在黑客团体具有世界级声誉的黑客。
>
> 黑客道德准则：
> （1）通往电脑的路不止一条
> （2）所有的信息都应当是免费和共享的
> （3）一定要打破电脑集权
> （4）在电脑上创造的是艺术和美
> （5）计算机将使生活更加美好
>
> 热衷挑战、崇尚自由、主张信息共享、反叛精神、破坏心理

网络攻击的步骤：

1. 信息收集，获取目标系统的信息，操作系统的类型和版本，主要提供的服务和服务进程的类型和版本，网络拓扑结构
2. 获得对系统的访问权力
3. 获得系统超级用户的权力。利用（2）的权力和系统的漏洞，可以修改文件，运行任何程序，留下下次入侵的缺口，或破坏整个系统
4. 消除入侵痕迹



## 一、信息收集

#### 初始信息收集

可以合法地获取公开信息，比如目标机构的网页、新闻、论坛等。

- Whois数据库：查询某个IP或域名是否已注册，以及注册时的详细信息

- 命令行利用DNS数据库：Nslookup，linux中的host等

- ping, traceroute

  > “Ping of death”: 发送特大ping数据包(>65535字节)导致机器崩溃, 许多老的操作系统都受影响

  可以利用防火墙来防范。

#### 扫描

- 主机扫描:发现系统存活情况
- 对端口扫描，发现哪些服务在运行
- 扫描器能够暴露网络上潜在的脆弱性，避免遭受不必要的攻击
- 操作系统指纹扫描:有进一步的功能，包括操作系统辨识、应用系统识别

端口扫描的技术已经非常成熟，目前有大量的商业、非商业的扫描器

##### 端口扫描

- 开放扫描(Open Scanning)：也称为全连接扫描，和开放的端口进行连接。会被目标主机的日志完整地记录下来。
- 半开扫描(Half-Open Scanning)：也称为SYN扫描，第三次握手回复一个复位的信号“RST”，不建立连接。
- 隐蔽扫描(Stealth Scanning)：SYNACK扫描或FIN扫描，若目标端口关闭：会回复 `RST` 包；若目标端口开放：会忽略该异常包，不做任何回复。隐蔽性最好，但不一定准确。



## 二、网络攻击

漏洞种类：

- 内存破坏漏洞：栈缓冲区溢出、堆缓冲区溢出、格式串问题、内存释放后重用、二次释放。
- 逻辑错误漏洞：安全检查的实现逻辑存在问题，导致安全机制被绕过。
- 输入验证漏洞：对用户的输入没有充分进行检查验证就用于后续操作，主要出现在Web应用程序中，导致的后果包括：SQL注入、跨站脚本执行等。
- 设计错误漏洞：系统在初始设计时，对安全机制考虑不充分，导致在设计阶段就已经引入漏洞。例如早期微软公司Windows账号的散列算法LM Hash存在设计缺陷。
- 配置错误漏洞：系统运维过程中存在不安全的配置状态

### 拒绝服务攻击

#### Ping of Death

发送特大ping数据包(>65535字节)导致机器崩溃, （有些系统在收到大量比最大包还要长的数据包，会挂起或者死机），许多老的操作系统都受影响

#### IP碎片

发送一系列高度碎片化的过大的ICMP数据包，某些TCP/IP（包括service pack 4以前的NT）在收到含有重叠偏移的伪造分段时无法处理，会崩溃。

##### Teardrop

<img src="./信息安全引论.assets/image-20260107144709726.png" alt="image-20260107144709726" style="zoom:40%;" />

#### Land

程序发送一个TCP SYN包，源地址与目的地址相同，源端口与目的端口相同。对Land攻击反应不同，许多UNIX实现将崩溃，NT变得极其缓慢（大约持续五分钟）。

#### SYN Flood

大量的半开连接。

#### Smurf

攻击者向一个广播地址发送ICMP Echo请求，并且用受害者的IP地址作为源地址，于是，广播地址网络上的每台机器响应这些Echo请求，同时向受害者主机发送ICMP Echo-Reply应答。

<img src="./信息安全引论.assets/image-20260107145033444.png" alt="image-20260107145033444" style="zoom:40%;" />

#### 分布式拒绝服务攻击

多台主机合作攻击一个目标。

<img src="./信息安全引论.assets/image-20260107140938175.png" alt="image-20260107140938175" style="zoom:50%;" />





## 三、防火墙技术

> 防火墙局限性：
>
> - 限制或关闭了一些有用但存在安全缺陷的网络服务，给用户带来使用的不便。
> - 目前防火墙对于来自网络内部的攻击还无能为力。
> - 防火墙不能防范不经过防火墙的攻击。
> - 可能带来传输延迟、瓶颈及单点失效。
> - 防火墙不能有效地防范[数据驱动式攻击][通过向某个程序发送数据，以产生非预期结果的攻击。eg. 数组越界]。
> - 作为一种被动的防护手段，防火墙不能防范因特网上不断出现的新的威胁和攻击。

### 防火墙体系结构

- 堡垒主机 Bastion Host：堡垒主机是一种配置了安全防范措施的网络上的计算机，堡垒主机为网络之间的通信提供了一个阻塞点，也就是说如果没有堡垒主机，网络之间将不能相互访问。
- 双宿主机 Dual-homed Host：有两个网络接口的计算机系统，一个接口接内部网，一个接口接外部网.
- DMZ(Demilitarized Zone，非军事区或者停火区)：在内部网络和外部网络之间增加的一个子网

1. 包过滤型防火墙

2. 双宿/多宿主机模式：防火墙拥有两个或多个连接到不同网络上的网络接口。

3. 屏蔽主机防火墙：由包过滤路由器和堡垒主机组成。堡垒主机可以实现应用层的一些控制。*实现的关键在于过滤路由器是否配置正确。需要保证堡垒主机不被越过。*

   <img src="./信息安全引论.assets/image-20260107142051980.png" alt="image-20260107142051980" style="zoom:40%;" />

4. 屏蔽子网模式：内部网络和外部网络均可访问屏蔽子网，但禁止它们穿过屏蔽子网通信。在这一配置中，即使堡垒主机被入侵者控制，内部网仍受到内部包过滤路由器的保护。

   <img src="./信息安全引论.assets/image-20260107142410556.png" alt="image-20260107142410556" style="zoom:40%;" />

5. 等等等等。

### 防火墙具体技术

#### 静态包过滤

根据流经该设备的数据包头信息，决定是否允许该数据包通过

重要的约定：

- 访问规则要使用IP地址，而不使用主机名或域名
- 不回应外部网络来的ICMP包
- 要丢弃所有通过外部网络适配器流入，且其源地址是来自受保护网络的包（一般是伪造了假IP地址）

> [!NOTE]
>
> 其他常用设置：
>
> - SYN 洪泛攻击：通过监视日志文件，让不断发送SYN置位包的主机不能通过防火墙。
> - 只允许ACK=1的外部包进入，这样使得外部包只能响应，无法主动发起连接。

##### 针对包过滤防火墙的攻击

1. IP地址欺骗：假冒内部IP地址
   - Sol. 在外部接口上阻止内部IP地址进入
2. 源路由攻击，即由源指定路由试图绕过防火墙
   - Sol. 禁止这样的选项
3. 小碎片攻击，利用IP分片功能把TCP头部切分到不同的分片中
   - 对策：丢弃分片太小的分片
4. 利用复杂协议和管理员的配置失误进入防火墙，比如利用一些可以通过的协议对内部进行探查

##### 静态包过滤的特点

- 优点：逻辑简单，价格便宜，对网络性能的影响较小，有较强的透明性。并且它的工作与应用层无关，无须改动任何客户机和主机上的应用程序，易于安装和使用。

- 弱点：需要非常了解各个协议，从而配置出恰当的过滤条件。只考虑了传输层和网络层的条件。

  

#### 动态包过滤

防火墙跟踪客户端口，可动态生成/删除规则，而不是打开全部高编号端口给外部访问，因而更安全。

- 优点：这类防火墙减少了端口的开放时间，提供了对几乎所有服务的支持。

- 缺点：不提供用户的鉴别机制。

  

#### 应用程序网关（代理服务器）

> 只有应用层有用户身份信息

<img src="./信息安全引论.assets/image-20260104171932619.png" alt="image-20260104171932619" style="zoom:50%;" />

网关理解应用协议，可以实施更细粒度的访问控制。对每一类应用，都需要一个专门的代理

- 优点：可以与鉴别、授权等安全手段方便的集成。非常安全。

- 缺点：灵活性不够。速度慢。

  

#### 电路级网关

在TCP层实现“应用程序网关”。

- 优点：效率高。通用性强，为一般的应用提供了一个框架。
- 缺点：应用程序还需要再修改。



#### 深度包检查技术

深度包检查（deep packet inspection，DPI）也称为完全包检查（complete packet inspection）和信息提取（Information extraction）。



#### 分布式防火墙

> 传统防火墙：依赖于防火墙一端可信，另一端是潜在的敌人。过于依赖物理拓扑结构。如果内网内部有机器被攻破，就内网全被破了。
>
> 现代防火墙：有个人电脑防火的需求。

以安全策略来划分内外网。



#### 防火墙设置技术

可以硬件实现（ASIC）、软件实现。

##### 双机热备

<img src="./信息安全引论.assets/image-20260105115404431.png" alt="image-20260105115404431" style="zoom:50%;" />

##### 负载均衡

<img src="./信息安全引论.assets/image-20260105115825104.png" alt="image-20260105115825104" style="zoom:50%;" />



#### 其他技术

- VPN
- NAT（则可以向外界隐藏内部网结构）
- IP与MAC绑定（防止假冒IP）
- ...

---



# Lecture 14. 安全电子邮件

## 一、电子邮件安全问题

安全的电子邮件主要是解决身份鉴别和保密性的安全问题。涉及到的问题：

1. 安全算法的选择

2. 系统邮件的信息格式：ASCII 文本可以直接发送，非ASCII文本通过编码转换为ASCII文本后发送

3. 如何实现鉴别和信任管理：公钥、如何相信公钥

   > PGP密钥：公钥环、私钥环，简单的信任模型，相当于把一个朋友介绍给另一个朋友
   > X.509只能被签名者签名一次
   > PEM简单的而又严格的全球认证分级

4. 邮件服务器的可靠性

   >防止来自外部的攻击：拒绝来自特定地址的连接请求、限制单个IP的连接数量
   >防止来自内部的攻击：实现用户身份的鉴别



## 二、PGP

> PGP - Pretty Good Privacy
>
> 作者：Phil Zimmermann
>
> PGP 已成为Internet 标准文档（RFC 3156）

PGP 用于对文本、电子邮件、文件、目录和整个磁盘分区进行签名、加密和解密等安全服务。

- 数字签名、消息加密、数据压缩、邮件兼容、数据分段

> [!NOTE]
>
> PGP成功的原因：
>
> 1. 选用生命力和安全性已经得到公众认可的算法。
> 2. 提供免费版本，且可用于多种平台，如Windows、Unix、Linux、Mac OSX，商业版本使用户得到很好的技术支持。
> 3. 不由政府或标准化组织控制。

### 过程

#### 签名过程

<img src="./信息安全引论.assets/image-20260105165657787.png" alt="image-20260105165657787" style="zoom:50%;" />



#### 发送过程

1. 随机产生一个对话密钥
2. 压缩消息，并用对话密钥加密压缩后的消息（在压缩之前签名）
3. 用对方的公钥加密对话密钥
4. 把加密后的消息和加密后的对话密钥一起发给对方

> [!NOTE]
>
> 如果同时给十个人发送邮件，那么只要产生一个会话密钥，用十个人的公钥分别加密后发送即可。这样内容只需要加密一次。



### 其他技术

#### 公钥管理

自己选择自己信任的人



#### E-mail 兼容性

加密后是任意的8位字节，需要转换到ASCII格式。

- Radix64 将3字节输入转换到4个ASCII字符，并带CRC校验。*长度扩大33%*
- 与压缩综合后，长度为：1.33x0.5xM = 0.665xM



#### 公钥环和私钥环

> [!NOTE]
>
> >  一个用户有多个公钥/私钥对时，接收者如何知道发送者是用了哪个公钥来加密会话密钥？
>
> 将公钥与消息一起传送太大了，所以传**密钥标识符**。
>
> - 定义KeyID 包括64个有效位：(KUa mod 2^64^)
>
> *KeyID同样也需要PGP数字签名。*

PGP在每一个节点上提供一对数据结构：

- 存储该节点拥有的公钥/私钥对；（私钥环）
- 存储本节点知道的其他用户的公钥；（公钥环）

<img src="./信息安全引论.assets/image-20260106095150950.png" alt="image-20260106095150950" style="zoom:50%;" />



#### 证书

PGP支持两种形式的证书：PGP证书与X.509证书（Root CA）

##### PGP信任模型

1. Direct Trust

   <img src="./信息安全引论.assets/image-20260106100421267.png" alt="image-20260106100421267" style="zoom:33%;" />

2. Hierarchical Trust

   <img src="./信息安全引论.assets/image-20260106100438356.png" alt="image-20260106100438356" style="zoom:30%;" />

3. A Web of Trust

   *中间有一点的表示我对它签名了（认为它的公钥是真的）*

   *箭头表示被签名。*

   *灰色表示完全信任，完全信任者签名的人那我也相信它的公钥是真的。*

   *半灰色表示半信任，两个半信任都对一人签名了（A&B-->H）那我就相信它的公钥是真的。*

   <img src="./信息安全引论.assets/image-20260106095757174.png" alt="image-20260106095757174" style="zoom:50%;" />

   ---
   
   
